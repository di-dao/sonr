// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/v1/core.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fcore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fcore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fv1_2fcore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fv1_2fcore_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fv1_2fcore_2eproto;
namespace common {
namespace v1 {
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Location_Placemark;
struct Location_PlacemarkDefaultTypeInternal;
extern Location_PlacemarkDefaultTypeInternal _Location_Placemark_default_instance_;
class MIME;
struct MIMEDefaultTypeInternal;
extern MIMEDefaultTypeInternal _MIME_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Peer;
struct PeerDefaultTypeInternal;
extern PeerDefaultTypeInternal _Peer_default_instance_;
class Peer_Device;
struct Peer_DeviceDefaultTypeInternal;
extern Peer_DeviceDefaultTypeInternal _Peer_Device_default_instance_;
class Profile;
struct ProfileDefaultTypeInternal;
extern ProfileDefaultTypeInternal _Profile_default_instance_;
class ProfileList;
struct ProfileListDefaultTypeInternal;
extern ProfileListDefaultTypeInternal _ProfileList_default_instance_;
class Social;
struct SocialDefaultTypeInternal;
extern SocialDefaultTypeInternal _Social_default_instance_;
}  // namespace v1
}  // namespace common
PROTOBUF_NAMESPACE_OPEN
template<> ::common::v1::Location* Arena::CreateMaybeMessage<::common::v1::Location>(Arena*);
template<> ::common::v1::Location_Placemark* Arena::CreateMaybeMessage<::common::v1::Location_Placemark>(Arena*);
template<> ::common::v1::MIME* Arena::CreateMaybeMessage<::common::v1::MIME>(Arena*);
template<> ::common::v1::Metadata* Arena::CreateMaybeMessage<::common::v1::Metadata>(Arena*);
template<> ::common::v1::Peer* Arena::CreateMaybeMessage<::common::v1::Peer>(Arena*);
template<> ::common::v1::Peer_Device* Arena::CreateMaybeMessage<::common::v1::Peer_Device>(Arena*);
template<> ::common::v1::Profile* Arena::CreateMaybeMessage<::common::v1::Profile>(Arena*);
template<> ::common::v1::ProfileList* Arena::CreateMaybeMessage<::common::v1::ProfileList>(Arena*);
template<> ::common::v1::Social* Arena::CreateMaybeMessage<::common::v1::Social>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace common {
namespace v1 {

enum MIME_Type : int {
  MIME_Type_TYPE_UNSPECIFIED = 0,
  MIME_Type_TYPE_AUDIO = 1,
  MIME_Type_TYPE_DOCUMENT = 2,
  MIME_Type_TYPE_IMAGE = 3,
  MIME_Type_TYPE_TEXT = 4,
  MIME_Type_TYPE_VIDEO = 5,
  MIME_Type_TYPE_URL = 6,
  MIME_Type_MIME_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MIME_Type_MIME_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MIME_Type_IsValid(int value);
constexpr MIME_Type MIME_Type_Type_MIN = MIME_Type_TYPE_UNSPECIFIED;
constexpr MIME_Type MIME_Type_Type_MAX = MIME_Type_TYPE_URL;
constexpr int MIME_Type_Type_ARRAYSIZE = MIME_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MIME_Type_descriptor();
template<typename T>
inline const std::string& MIME_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MIME_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MIME_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MIME_Type_descriptor(), enum_t_value);
}
inline bool MIME_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MIME_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MIME_Type>(
    MIME_Type_descriptor(), name, value);
}
enum Peer_Status : int {
  Peer_Status_STATUS_UNSPECIFIED = 0,
  Peer_Status_STATUS_ONLINE = 1,
  Peer_Status_STATUS_AWAY = 2,
  Peer_Status_STATUS_BUSY = 3,
  Peer_Status_Peer_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Peer_Status_Peer_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Peer_Status_IsValid(int value);
constexpr Peer_Status Peer_Status_Status_MIN = Peer_Status_STATUS_UNSPECIFIED;
constexpr Peer_Status Peer_Status_Status_MAX = Peer_Status_STATUS_BUSY;
constexpr int Peer_Status_Status_ARRAYSIZE = Peer_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Peer_Status_descriptor();
template<typename T>
inline const std::string& Peer_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Peer_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Peer_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Peer_Status_descriptor(), enum_t_value);
}
inline bool Peer_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Peer_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Peer_Status>(
    Peer_Status_descriptor(), name, value);
}
enum Social_Media : int {
  Social_Media_MEDIA_UNSPECIFIED = 0,
  Social_Media_MEDIA_FACEBOOK = 1,
  Social_Media_MEDIA_TWITTER = 2,
  Social_Media_MEDIA_MEDIUM = 3,
  Social_Media_MEDIA_TIKTOK = 4,
  Social_Media_MEDIA_INSTAGRAM = 5,
  Social_Media_MEDIA_YOUTUBE = 6,
  Social_Media_MEDIA_GITHUB = 7,
  Social_Media_MEDIA_SNAPCHAT = 8,
  Social_Media_MEDIA_SPOTIFY = 9,
  Social_Media_Social_Media_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Social_Media_Social_Media_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Social_Media_IsValid(int value);
constexpr Social_Media Social_Media_Media_MIN = Social_Media_MEDIA_UNSPECIFIED;
constexpr Social_Media Social_Media_Media_MAX = Social_Media_MEDIA_SPOTIFY;
constexpr int Social_Media_Media_ARRAYSIZE = Social_Media_Media_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Social_Media_descriptor();
template<typename T>
inline const std::string& Social_Media_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Social_Media>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Social_Media_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Social_Media_descriptor(), enum_t_value);
}
inline bool Social_Media_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Social_Media* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Social_Media>(
    Social_Media_descriptor(), name, value);
}
enum Connection : int {
  CONNECTION_UNSPECIFIED = 0,
  CONNECTION_WIFI = 1,
  CONNECTION_ETHERNET = 2,
  CONNECTION_MOBILE = 3,
  CONNECTION_OFFLINE = 4,
  Connection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Connection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Connection_IsValid(int value);
constexpr Connection Connection_MIN = CONNECTION_UNSPECIFIED;
constexpr Connection Connection_MAX = CONNECTION_OFFLINE;
constexpr int Connection_ARRAYSIZE = Connection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Connection_descriptor();
template<typename T>
inline const std::string& Connection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Connection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Connection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Connection_descriptor(), enum_t_value);
}
inline bool Connection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Connection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Connection>(
    Connection_descriptor(), name, value);
}
enum Environment : int {
  ENVIRONMENT_UNSPECIFIED = 0,
  ENVIRONMENT_DEVELOPMENT = 1,
  ENVIRONMENT_PRODUCTION = 2,
  Environment_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Environment_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Environment_IsValid(int value);
constexpr Environment Environment_MIN = ENVIRONMENT_UNSPECIFIED;
constexpr Environment Environment_MAX = ENVIRONMENT_PRODUCTION;
constexpr int Environment_ARRAYSIZE = Environment_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Environment_descriptor();
template<typename T>
inline const std::string& Environment_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Environment>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Environment_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Environment_descriptor(), enum_t_value);
}
inline bool Environment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Environment* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Environment>(
    Environment_descriptor(), name, value);
}
// ===================================================================

class Location_Placemark final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Location.Placemark) */ {
 public:
  inline Location_Placemark() : Location_Placemark(nullptr) {}
  ~Location_Placemark() override;
  explicit constexpr Location_Placemark(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location_Placemark(const Location_Placemark& from);
  Location_Placemark(Location_Placemark&& from) noexcept
    : Location_Placemark() {
    *this = ::std::move(from);
  }

  inline Location_Placemark& operator=(const Location_Placemark& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location_Placemark& operator=(Location_Placemark&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location_Placemark& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location_Placemark* internal_default_instance() {
    return reinterpret_cast<const Location_Placemark*>(
               &_Location_Placemark_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Location_Placemark& a, Location_Placemark& b) {
    a.Swap(&b);
  }
  inline void Swap(Location_Placemark* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location_Placemark* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location_Placemark* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location_Placemark>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location_Placemark& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Location_Placemark& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location_Placemark* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Location.Placemark";
  }
  protected:
  explicit Location_Placemark(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStreetFieldNumber = 2,
    kIsoCountryCodeFieldNumber = 3,
    kCountryFieldNumber = 4,
    kPostalCodeFieldNumber = 5,
    kAdministrativeAreaFieldNumber = 6,
    kSubAdministrativeAreaFieldNumber = 7,
    kLocalityFieldNumber = 8,
    kSubLocalityFieldNumber = 9,
    kThoroughfareFieldNumber = 10,
    kSubThoroughfareFieldNumber = 11,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string street = 2 [json_name = "street"];
  void clear_street();
  const std::string& street() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_street(ArgT0&& arg0, ArgT... args);
  std::string* mutable_street();
  PROTOBUF_NODISCARD std::string* release_street();
  void set_allocated_street(std::string* street);
  private:
  const std::string& _internal_street() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_street(const std::string& value);
  std::string* _internal_mutable_street();
  public:

  // string iso_country_code = 3 [json_name = "isoCountryCode"];
  void clear_iso_country_code();
  const std::string& iso_country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iso_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iso_country_code();
  PROTOBUF_NODISCARD std::string* release_iso_country_code();
  void set_allocated_iso_country_code(std::string* iso_country_code);
  private:
  const std::string& _internal_iso_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iso_country_code(const std::string& value);
  std::string* _internal_mutable_iso_country_code();
  public:

  // string country = 4 [json_name = "country"];
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // string postal_code = 5 [json_name = "postalCode"];
  void clear_postal_code();
  const std::string& postal_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_postal_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_postal_code();
  PROTOBUF_NODISCARD std::string* release_postal_code();
  void set_allocated_postal_code(std::string* postal_code);
  private:
  const std::string& _internal_postal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_postal_code(const std::string& value);
  std::string* _internal_mutable_postal_code();
  public:

  // string administrative_area = 6 [json_name = "administrativeArea"];
  void clear_administrative_area();
  const std::string& administrative_area() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_administrative_area(ArgT0&& arg0, ArgT... args);
  std::string* mutable_administrative_area();
  PROTOBUF_NODISCARD std::string* release_administrative_area();
  void set_allocated_administrative_area(std::string* administrative_area);
  private:
  const std::string& _internal_administrative_area() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_administrative_area(const std::string& value);
  std::string* _internal_mutable_administrative_area();
  public:

  // string sub_administrative_area = 7 [json_name = "subAdministrativeArea"];
  void clear_sub_administrative_area();
  const std::string& sub_administrative_area() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sub_administrative_area(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sub_administrative_area();
  PROTOBUF_NODISCARD std::string* release_sub_administrative_area();
  void set_allocated_sub_administrative_area(std::string* sub_administrative_area);
  private:
  const std::string& _internal_sub_administrative_area() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_administrative_area(const std::string& value);
  std::string* _internal_mutable_sub_administrative_area();
  public:

  // string locality = 8 [json_name = "locality"];
  void clear_locality();
  const std::string& locality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locality();
  PROTOBUF_NODISCARD std::string* release_locality();
  void set_allocated_locality(std::string* locality);
  private:
  const std::string& _internal_locality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locality(const std::string& value);
  std::string* _internal_mutable_locality();
  public:

  // string sub_locality = 9 [json_name = "subLocality"];
  void clear_sub_locality();
  const std::string& sub_locality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sub_locality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sub_locality();
  PROTOBUF_NODISCARD std::string* release_sub_locality();
  void set_allocated_sub_locality(std::string* sub_locality);
  private:
  const std::string& _internal_sub_locality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_locality(const std::string& value);
  std::string* _internal_mutable_sub_locality();
  public:

  // string thoroughfare = 10 [json_name = "thoroughfare"];
  void clear_thoroughfare();
  const std::string& thoroughfare() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thoroughfare(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thoroughfare();
  PROTOBUF_NODISCARD std::string* release_thoroughfare();
  void set_allocated_thoroughfare(std::string* thoroughfare);
  private:
  const std::string& _internal_thoroughfare() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thoroughfare(const std::string& value);
  std::string* _internal_mutable_thoroughfare();
  public:

  // string sub_thoroughfare = 11 [json_name = "subThoroughfare"];
  void clear_sub_thoroughfare();
  const std::string& sub_thoroughfare() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sub_thoroughfare(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sub_thoroughfare();
  PROTOBUF_NODISCARD std::string* release_sub_thoroughfare();
  void set_allocated_sub_thoroughfare(std::string* sub_thoroughfare);
  private:
  const std::string& _internal_sub_thoroughfare() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sub_thoroughfare(const std::string& value);
  std::string* _internal_mutable_sub_thoroughfare();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Location.Placemark)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr street_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iso_country_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr postal_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr administrative_area_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_administrative_area_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locality_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_locality_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thoroughfare_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sub_thoroughfare_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Location final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  ~Location() override;
  explicit constexpr Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Location& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Location& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Location_Placemark Placemark;

  // accessors -------------------------------------------------------

  enum : int {
    kPlacemarkFieldNumber = 3,
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kLastModifiedFieldNumber = 4,
  };
  // .common.v1.Location.Placemark placemark = 3 [json_name = "placemark"];
  bool has_placemark() const;
  private:
  bool _internal_has_placemark() const;
  public:
  void clear_placemark();
  const ::common::v1::Location_Placemark& placemark() const;
  PROTOBUF_NODISCARD ::common::v1::Location_Placemark* release_placemark();
  ::common::v1::Location_Placemark* mutable_placemark();
  void set_allocated_placemark(::common::v1::Location_Placemark* placemark);
  private:
  const ::common::v1::Location_Placemark& _internal_placemark() const;
  ::common::v1::Location_Placemark* _internal_mutable_placemark();
  public:
  void unsafe_arena_set_allocated_placemark(
      ::common::v1::Location_Placemark* placemark);
  ::common::v1::Location_Placemark* unsafe_arena_release_placemark();

  // double latitude = 1 [json_name = "latitude"];
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2 [json_name = "longitude"];
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // int64 last_modified = 4 [json_name = "lastModified"];
  void clear_last_modified();
  int64_t last_modified() const;
  void set_last_modified(int64_t value);
  private:
  int64_t _internal_last_modified() const;
  void _internal_set_last_modified(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::v1::Location_Placemark* placemark_;
  double latitude_;
  double longitude_;
  int64_t last_modified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit constexpr Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Metadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
    kTimestampFieldNumber = 1,
  };
  // string node_id = 2 [json_name = "nodeId"];
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // bytes signature = 3 [json_name = "signature"];
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // bytes public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // int64 timestamp = 1 [json_name = "timestamp"];
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  int64_t timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class MIME final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.MIME) */ {
 public:
  inline MIME() : MIME(nullptr) {}
  ~MIME() override;
  explicit constexpr MIME(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MIME(const MIME& from);
  MIME(MIME&& from) noexcept
    : MIME() {
    *this = ::std::move(from);
  }

  inline MIME& operator=(const MIME& from) {
    CopyFrom(from);
    return *this;
  }
  inline MIME& operator=(MIME&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MIME& default_instance() {
    return *internal_default_instance();
  }
  static inline const MIME* internal_default_instance() {
    return reinterpret_cast<const MIME*>(
               &_MIME_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MIME& a, MIME& b) {
    a.Swap(&b);
  }
  inline void Swap(MIME* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MIME* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MIME* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MIME>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MIME& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MIME& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MIME* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.MIME";
  }
  protected:
  explicit MIME(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MIME_Type Type;
  static constexpr Type TYPE_UNSPECIFIED =
    MIME_Type_TYPE_UNSPECIFIED;
  static constexpr Type TYPE_AUDIO =
    MIME_Type_TYPE_AUDIO;
  static constexpr Type TYPE_DOCUMENT =
    MIME_Type_TYPE_DOCUMENT;
  static constexpr Type TYPE_IMAGE =
    MIME_Type_TYPE_IMAGE;
  static constexpr Type TYPE_TEXT =
    MIME_Type_TYPE_TEXT;
  static constexpr Type TYPE_VIDEO =
    MIME_Type_TYPE_VIDEO;
  static constexpr Type TYPE_URL =
    MIME_Type_TYPE_URL;
  static inline bool Type_IsValid(int value) {
    return MIME_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    MIME_Type_Type_MIN;
  static constexpr Type Type_MAX =
    MIME_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    MIME_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return MIME_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return MIME_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return MIME_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubtypeFieldNumber = 2,
    kValueFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string subtype = 2 [json_name = "subtype"];
  void clear_subtype();
  const std::string& subtype() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtype(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtype();
  PROTOBUF_NODISCARD std::string* release_subtype();
  void set_allocated_subtype(std::string* subtype);
  private:
  const std::string& _internal_subtype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtype(const std::string& value);
  std::string* _internal_mutable_subtype();
  public:

  // string value = 3 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .common.v1.MIME.Type type = 1 [json_name = "type"];
  void clear_type();
  ::common::v1::MIME_Type type() const;
  void set_type(::common::v1::MIME_Type value);
  private:
  ::common::v1::MIME_Type _internal_type() const;
  void _internal_set_type(::common::v1::MIME_Type value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.MIME)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Peer_Device final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Peer.Device) */ {
 public:
  inline Peer_Device() : Peer_Device(nullptr) {}
  ~Peer_Device() override;
  explicit constexpr Peer_Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Peer_Device(const Peer_Device& from);
  Peer_Device(Peer_Device&& from) noexcept
    : Peer_Device() {
    *this = ::std::move(from);
  }

  inline Peer_Device& operator=(const Peer_Device& from) {
    CopyFrom(from);
    return *this;
  }
  inline Peer_Device& operator=(Peer_Device&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Peer_Device& default_instance() {
    return *internal_default_instance();
  }
  static inline const Peer_Device* internal_default_instance() {
    return reinterpret_cast<const Peer_Device*>(
               &_Peer_Device_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Peer_Device& a, Peer_Device& b) {
    a.Swap(&b);
  }
  inline void Swap(Peer_Device* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Peer_Device* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Peer_Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Peer_Device>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Peer_Device& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Peer_Device& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Peer_Device* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Peer.Device";
  }
  protected:
  explicit Peer_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kHostNameFieldNumber = 2,
    kOsFieldNumber = 3,
    kArchFieldNumber = 4,
    kModelFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string host_name = 2 [json_name = "hostName"];
  void clear_host_name();
  const std::string& host_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // string os = 3 [json_name = "os"];
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // string arch = 4 [json_name = "arch"];
  void clear_arch();
  const std::string& arch() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_arch(ArgT0&& arg0, ArgT... args);
  std::string* mutable_arch();
  PROTOBUF_NODISCARD std::string* release_arch();
  void set_allocated_arch(std::string* arch);
  private:
  const std::string& _internal_arch() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_arch(const std::string& value);
  std::string* _internal_mutable_arch();
  public:

  // string model = 5 [json_name = "model"];
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Peer.Device)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr arch_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Peer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Peer) */ {
 public:
  inline Peer() : Peer(nullptr) {}
  ~Peer() override;
  explicit constexpr Peer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Peer(const Peer& from);
  Peer(Peer&& from) noexcept
    : Peer() {
    *this = ::std::move(from);
  }

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Peer& operator=(Peer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Peer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Peer* internal_default_instance() {
    return reinterpret_cast<const Peer*>(
               &_Peer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Peer& a, Peer& b) {
    a.Swap(&b);
  }
  inline void Swap(Peer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Peer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Peer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Peer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Peer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Peer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Peer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Peer";
  }
  protected:
  explicit Peer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Peer_Device Device;

  typedef Peer_Status Status;
  static constexpr Status STATUS_UNSPECIFIED =
    Peer_Status_STATUS_UNSPECIFIED;
  static constexpr Status STATUS_ONLINE =
    Peer_Status_STATUS_ONLINE;
  static constexpr Status STATUS_AWAY =
    Peer_Status_STATUS_AWAY;
  static constexpr Status STATUS_BUSY =
    Peer_Status_STATUS_BUSY;
  static inline bool Status_IsValid(int value) {
    return Peer_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    Peer_Status_Status_MIN;
  static constexpr Status Status_MAX =
    Peer_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    Peer_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return Peer_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return Peer_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return Peer_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPublicKeyFieldNumber = 5,
    kPeerIdFieldNumber = 6,
    kDeviceFieldNumber = 3,
    kProfileFieldNumber = 4,
    kLastModifiedFieldNumber = 7,
    kStatusFieldNumber = 2,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // bytes public_key = 5 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // string peer_id = 6 [json_name = "peerId"];
  void clear_peer_id();
  const std::string& peer_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_id();
  PROTOBUF_NODISCARD std::string* release_peer_id();
  void set_allocated_peer_id(std::string* peer_id);
  private:
  const std::string& _internal_peer_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_id(const std::string& value);
  std::string* _internal_mutable_peer_id();
  public:

  // .common.v1.Peer.Device device = 3 [json_name = "device"];
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const ::common::v1::Peer_Device& device() const;
  PROTOBUF_NODISCARD ::common::v1::Peer_Device* release_device();
  ::common::v1::Peer_Device* mutable_device();
  void set_allocated_device(::common::v1::Peer_Device* device);
  private:
  const ::common::v1::Peer_Device& _internal_device() const;
  ::common::v1::Peer_Device* _internal_mutable_device();
  public:
  void unsafe_arena_set_allocated_device(
      ::common::v1::Peer_Device* device);
  ::common::v1::Peer_Device* unsafe_arena_release_device();

  // .common.v1.Profile profile = 4 [json_name = "profile"];
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  const ::common::v1::Profile& profile() const;
  PROTOBUF_NODISCARD ::common::v1::Profile* release_profile();
  ::common::v1::Profile* mutable_profile();
  void set_allocated_profile(::common::v1::Profile* profile);
  private:
  const ::common::v1::Profile& _internal_profile() const;
  ::common::v1::Profile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::common::v1::Profile* profile);
  ::common::v1::Profile* unsafe_arena_release_profile();

  // int64 last_modified = 7 [json_name = "lastModified"];
  void clear_last_modified();
  int64_t last_modified() const;
  void set_last_modified(int64_t value);
  private:
  int64_t _internal_last_modified() const;
  void _internal_set_last_modified(int64_t value);
  public:

  // .common.v1.Peer.Status status = 2 [json_name = "status"];
  void clear_status();
  ::common::v1::Peer_Status status() const;
  void set_status(::common::v1::Peer_Status value);
  private:
  ::common::v1::Peer_Status _internal_status() const;
  void _internal_set_status(::common::v1::Peer_Status value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Peer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_id_;
  ::common::v1::Peer_Device* device_;
  ::common::v1::Profile* profile_;
  int64_t last_modified_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Profile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Profile) */ {
 public:
  inline Profile() : Profile(nullptr) {}
  ~Profile() override;
  explicit constexpr Profile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Profile(const Profile& from);
  Profile(Profile&& from) noexcept
    : Profile() {
    *this = ::std::move(from);
  }

  inline Profile& operator=(const Profile& from) {
    CopyFrom(from);
    return *this;
  }
  inline Profile& operator=(Profile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Profile& default_instance() {
    return *internal_default_instance();
  }
  static inline const Profile* internal_default_instance() {
    return reinterpret_cast<const Profile*>(
               &_Profile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Profile& a, Profile& b) {
    a.Swap(&b);
  }
  inline void Swap(Profile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Profile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Profile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Profile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Profile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Profile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Profile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Profile";
  }
  protected:
  explicit Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSocialsFieldNumber = 7,
    kSNameFieldNumber = 1,
    kFirstNameFieldNumber = 2,
    kLastNameFieldNumber = 3,
    kPictureFieldNumber = 4,
    kBioFieldNumber = 6,
    kLastModifiedFieldNumber = 8,
  };
  // repeated .common.v1.Social socials = 7 [json_name = "socials"];
  int socials_size() const;
  private:
  int _internal_socials_size() const;
  public:
  void clear_socials();
  ::common::v1::Social* mutable_socials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Social >*
      mutable_socials();
  private:
  const ::common::v1::Social& _internal_socials(int index) const;
  ::common::v1::Social* _internal_add_socials();
  public:
  const ::common::v1::Social& socials(int index) const;
  ::common::v1::Social* add_socials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Social >&
      socials() const;

  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string first_name = 2 [json_name = "firstName"];
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // string last_name = 3 [json_name = "lastName"];
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // bytes picture = 4 [json_name = "picture"];
  void clear_picture();
  const std::string& picture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picture();
  PROTOBUF_NODISCARD std::string* release_picture();
  void set_allocated_picture(std::string* picture);
  private:
  const std::string& _internal_picture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picture(const std::string& value);
  std::string* _internal_mutable_picture();
  public:

  // string bio = 6 [json_name = "bio"];
  void clear_bio();
  const std::string& bio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bio();
  PROTOBUF_NODISCARD std::string* release_bio();
  void set_allocated_bio(std::string* bio);
  private:
  const std::string& _internal_bio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bio(const std::string& value);
  std::string* _internal_mutable_bio();
  public:

  // int64 last_modified = 8 [json_name = "lastModified"];
  void clear_last_modified();
  int64_t last_modified() const;
  void set_last_modified(int64_t value);
  private:
  int64_t _internal_last_modified() const;
  void _internal_set_last_modified(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Profile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Social > socials_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picture_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bio_;
  int64_t last_modified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class ProfileList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ProfileList) */ {
 public:
  inline ProfileList() : ProfileList(nullptr) {}
  ~ProfileList() override;
  explicit constexpr ProfileList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProfileList(const ProfileList& from);
  ProfileList(ProfileList&& from) noexcept
    : ProfileList() {
    *this = ::std::move(from);
  }

  inline ProfileList& operator=(const ProfileList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProfileList& operator=(ProfileList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProfileList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProfileList* internal_default_instance() {
    return reinterpret_cast<const ProfileList*>(
               &_ProfileList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ProfileList& a, ProfileList& b) {
    a.Swap(&b);
  }
  inline void Swap(ProfileList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProfileList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProfileList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProfileList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProfileList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProfileList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ProfileList";
  }
  protected:
  explicit ProfileList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfilesFieldNumber = 1,
    kKeyFieldNumber = 3,
    kCreatedAtFieldNumber = 2,
    kLastModifiedFieldNumber = 4,
  };
  // repeated .common.v1.Profile profiles = 1 [json_name = "profiles"];
  int profiles_size() const;
  private:
  int _internal_profiles_size() const;
  public:
  void clear_profiles();
  ::common::v1::Profile* mutable_profiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Profile >*
      mutable_profiles();
  private:
  const ::common::v1::Profile& _internal_profiles(int index) const;
  ::common::v1::Profile* _internal_add_profiles();
  public:
  const ::common::v1::Profile& profiles(int index) const;
  ::common::v1::Profile* add_profiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Profile >&
      profiles() const;

  // string key = 3 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // int64 created_at = 2 [json_name = "createdAt"];
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 last_modified = 4 [json_name = "lastModified"];
  void clear_last_modified();
  int64_t last_modified() const;
  void set_last_modified(int64_t value);
  private:
  int64_t _internal_last_modified() const;
  void _internal_set_last_modified(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ProfileList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Profile > profiles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  int64_t created_at_;
  int64_t last_modified_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// -------------------------------------------------------------------

class Social final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Social) */ {
 public:
  inline Social() : Social(nullptr) {}
  ~Social() override;
  explicit constexpr Social(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Social(const Social& from);
  Social(Social&& from) noexcept
    : Social() {
    *this = ::std::move(from);
  }

  inline Social& operator=(const Social& from) {
    CopyFrom(from);
    return *this;
  }
  inline Social& operator=(Social&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Social& default_instance() {
    return *internal_default_instance();
  }
  static inline const Social* internal_default_instance() {
    return reinterpret_cast<const Social*>(
               &_Social_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Social& a, Social& b) {
    a.Swap(&b);
  }
  inline void Swap(Social* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Social* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Social* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Social>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Social& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Social& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Social* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Social";
  }
  protected:
  explicit Social(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Social_Media Media;
  static constexpr Media MEDIA_UNSPECIFIED =
    Social_Media_MEDIA_UNSPECIFIED;
  static constexpr Media MEDIA_FACEBOOK =
    Social_Media_MEDIA_FACEBOOK;
  static constexpr Media MEDIA_TWITTER =
    Social_Media_MEDIA_TWITTER;
  static constexpr Media MEDIA_MEDIUM =
    Social_Media_MEDIA_MEDIUM;
  static constexpr Media MEDIA_TIKTOK =
    Social_Media_MEDIA_TIKTOK;
  static constexpr Media MEDIA_INSTAGRAM =
    Social_Media_MEDIA_INSTAGRAM;
  static constexpr Media MEDIA_YOUTUBE =
    Social_Media_MEDIA_YOUTUBE;
  static constexpr Media MEDIA_GITHUB =
    Social_Media_MEDIA_GITHUB;
  static constexpr Media MEDIA_SNAPCHAT =
    Social_Media_MEDIA_SNAPCHAT;
  static constexpr Media MEDIA_SPOTIFY =
    Social_Media_MEDIA_SPOTIFY;
  static inline bool Media_IsValid(int value) {
    return Social_Media_IsValid(value);
  }
  static constexpr Media Media_MIN =
    Social_Media_Media_MIN;
  static constexpr Media Media_MAX =
    Social_Media_Media_MAX;
  static constexpr int Media_ARRAYSIZE =
    Social_Media_Media_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Media_descriptor() {
    return Social_Media_descriptor();
  }
  template<typename T>
  static inline const std::string& Media_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Media>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Media_Name.");
    return Social_Media_Name(enum_t_value);
  }
  static inline bool Media_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Media* value) {
    return Social_Media_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 2,
    kUrlFieldNumber = 3,
    kPictureFieldNumber = 4,
    kValidFieldNumber = 1,
    kMediaFieldNumber = 5,
  };
  // string username = 2 [json_name = "username"];
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string url = 3 [json_name = "url"];
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes picture = 4 [json_name = "picture"];
  void clear_picture();
  const std::string& picture() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picture(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picture();
  PROTOBUF_NODISCARD std::string* release_picture();
  void set_allocated_picture(std::string* picture);
  private:
  const std::string& _internal_picture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picture(const std::string& value);
  std::string* _internal_mutable_picture();
  public:

  // bool valid = 1 [json_name = "valid"];
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // .common.v1.Social.Media media = 5 [json_name = "media"];
  void clear_media();
  ::common::v1::Social_Media media() const;
  void set_media(::common::v1::Social_Media value);
  private:
  ::common::v1::Social_Media _internal_media() const;
  void _internal_set_media(::common::v1::Social_Media value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.Social)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picture_;
  bool valid_;
  int media_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fcore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Location_Placemark

// string name = 1 [json_name = "name"];
inline void Location_Placemark::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Location_Placemark::name() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.name)
}
inline std::string* Location_Placemark::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.name)
  return _s;
}
inline const std::string& Location_Placemark::_internal_name() const {
  return name_.Get();
}
inline void Location_Placemark::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_name() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.name)
}

// string street = 2 [json_name = "street"];
inline void Location_Placemark::clear_street() {
  street_.ClearToEmpty();
}
inline const std::string& Location_Placemark::street() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.street)
  return _internal_street();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_street(ArgT0&& arg0, ArgT... args) {
 
 street_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.street)
}
inline std::string* Location_Placemark::mutable_street() {
  std::string* _s = _internal_mutable_street();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.street)
  return _s;
}
inline const std::string& Location_Placemark::_internal_street() const {
  return street_.Get();
}
inline void Location_Placemark::_internal_set_street(const std::string& value) {
  
  street_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_street() {
  
  return street_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_street() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.street)
  return street_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_street(std::string* street) {
  if (street != nullptr) {
    
  } else {
    
  }
  street_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), street,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (street_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    street_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.street)
}

// string iso_country_code = 3 [json_name = "isoCountryCode"];
inline void Location_Placemark::clear_iso_country_code() {
  iso_country_code_.ClearToEmpty();
}
inline const std::string& Location_Placemark::iso_country_code() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.iso_country_code)
  return _internal_iso_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_iso_country_code(ArgT0&& arg0, ArgT... args) {
 
 iso_country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.iso_country_code)
}
inline std::string* Location_Placemark::mutable_iso_country_code() {
  std::string* _s = _internal_mutable_iso_country_code();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.iso_country_code)
  return _s;
}
inline const std::string& Location_Placemark::_internal_iso_country_code() const {
  return iso_country_code_.Get();
}
inline void Location_Placemark::_internal_set_iso_country_code(const std::string& value) {
  
  iso_country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_iso_country_code() {
  
  return iso_country_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_iso_country_code() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.iso_country_code)
  return iso_country_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_iso_country_code(std::string* iso_country_code) {
  if (iso_country_code != nullptr) {
    
  } else {
    
  }
  iso_country_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iso_country_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iso_country_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iso_country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.iso_country_code)
}

// string country = 4 [json_name = "country"];
inline void Location_Placemark::clear_country() {
  country_.ClearToEmpty();
}
inline const std::string& Location_Placemark::country() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_country(ArgT0&& arg0, ArgT... args) {
 
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.country)
}
inline std::string* Location_Placemark::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.country)
  return _s;
}
inline const std::string& Location_Placemark::_internal_country() const {
  return country_.Get();
}
inline void Location_Placemark::_internal_set_country(const std::string& value) {
  
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_country() {
  
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_country() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.country)
  return country_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    
  } else {
    
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.country)
}

// string postal_code = 5 [json_name = "postalCode"];
inline void Location_Placemark::clear_postal_code() {
  postal_code_.ClearToEmpty();
}
inline const std::string& Location_Placemark::postal_code() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.postal_code)
  return _internal_postal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_postal_code(ArgT0&& arg0, ArgT... args) {
 
 postal_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.postal_code)
}
inline std::string* Location_Placemark::mutable_postal_code() {
  std::string* _s = _internal_mutable_postal_code();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.postal_code)
  return _s;
}
inline const std::string& Location_Placemark::_internal_postal_code() const {
  return postal_code_.Get();
}
inline void Location_Placemark::_internal_set_postal_code(const std::string& value) {
  
  postal_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_postal_code() {
  
  return postal_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_postal_code() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.postal_code)
  return postal_code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_postal_code(std::string* postal_code) {
  if (postal_code != nullptr) {
    
  } else {
    
  }
  postal_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), postal_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (postal_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    postal_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.postal_code)
}

// string administrative_area = 6 [json_name = "administrativeArea"];
inline void Location_Placemark::clear_administrative_area() {
  administrative_area_.ClearToEmpty();
}
inline const std::string& Location_Placemark::administrative_area() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.administrative_area)
  return _internal_administrative_area();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_administrative_area(ArgT0&& arg0, ArgT... args) {
 
 administrative_area_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.administrative_area)
}
inline std::string* Location_Placemark::mutable_administrative_area() {
  std::string* _s = _internal_mutable_administrative_area();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.administrative_area)
  return _s;
}
inline const std::string& Location_Placemark::_internal_administrative_area() const {
  return administrative_area_.Get();
}
inline void Location_Placemark::_internal_set_administrative_area(const std::string& value) {
  
  administrative_area_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_administrative_area() {
  
  return administrative_area_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_administrative_area() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.administrative_area)
  return administrative_area_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_administrative_area(std::string* administrative_area) {
  if (administrative_area != nullptr) {
    
  } else {
    
  }
  administrative_area_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), administrative_area,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (administrative_area_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    administrative_area_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.administrative_area)
}

// string sub_administrative_area = 7 [json_name = "subAdministrativeArea"];
inline void Location_Placemark::clear_sub_administrative_area() {
  sub_administrative_area_.ClearToEmpty();
}
inline const std::string& Location_Placemark::sub_administrative_area() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.sub_administrative_area)
  return _internal_sub_administrative_area();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_sub_administrative_area(ArgT0&& arg0, ArgT... args) {
 
 sub_administrative_area_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.sub_administrative_area)
}
inline std::string* Location_Placemark::mutable_sub_administrative_area() {
  std::string* _s = _internal_mutable_sub_administrative_area();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.sub_administrative_area)
  return _s;
}
inline const std::string& Location_Placemark::_internal_sub_administrative_area() const {
  return sub_administrative_area_.Get();
}
inline void Location_Placemark::_internal_set_sub_administrative_area(const std::string& value) {
  
  sub_administrative_area_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_sub_administrative_area() {
  
  return sub_administrative_area_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_sub_administrative_area() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.sub_administrative_area)
  return sub_administrative_area_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_sub_administrative_area(std::string* sub_administrative_area) {
  if (sub_administrative_area != nullptr) {
    
  } else {
    
  }
  sub_administrative_area_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_administrative_area,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sub_administrative_area_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sub_administrative_area_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.sub_administrative_area)
}

// string locality = 8 [json_name = "locality"];
inline void Location_Placemark::clear_locality() {
  locality_.ClearToEmpty();
}
inline const std::string& Location_Placemark::locality() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.locality)
  return _internal_locality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_locality(ArgT0&& arg0, ArgT... args) {
 
 locality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.locality)
}
inline std::string* Location_Placemark::mutable_locality() {
  std::string* _s = _internal_mutable_locality();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.locality)
  return _s;
}
inline const std::string& Location_Placemark::_internal_locality() const {
  return locality_.Get();
}
inline void Location_Placemark::_internal_set_locality(const std::string& value) {
  
  locality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_locality() {
  
  return locality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_locality() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.locality)
  return locality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_locality(std::string* locality) {
  if (locality != nullptr) {
    
  } else {
    
  }
  locality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locality,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locality_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locality_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.locality)
}

// string sub_locality = 9 [json_name = "subLocality"];
inline void Location_Placemark::clear_sub_locality() {
  sub_locality_.ClearToEmpty();
}
inline const std::string& Location_Placemark::sub_locality() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.sub_locality)
  return _internal_sub_locality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_sub_locality(ArgT0&& arg0, ArgT... args) {
 
 sub_locality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.sub_locality)
}
inline std::string* Location_Placemark::mutable_sub_locality() {
  std::string* _s = _internal_mutable_sub_locality();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.sub_locality)
  return _s;
}
inline const std::string& Location_Placemark::_internal_sub_locality() const {
  return sub_locality_.Get();
}
inline void Location_Placemark::_internal_set_sub_locality(const std::string& value) {
  
  sub_locality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_sub_locality() {
  
  return sub_locality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_sub_locality() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.sub_locality)
  return sub_locality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_sub_locality(std::string* sub_locality) {
  if (sub_locality != nullptr) {
    
  } else {
    
  }
  sub_locality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_locality,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sub_locality_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sub_locality_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.sub_locality)
}

// string thoroughfare = 10 [json_name = "thoroughfare"];
inline void Location_Placemark::clear_thoroughfare() {
  thoroughfare_.ClearToEmpty();
}
inline const std::string& Location_Placemark::thoroughfare() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.thoroughfare)
  return _internal_thoroughfare();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_thoroughfare(ArgT0&& arg0, ArgT... args) {
 
 thoroughfare_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.thoroughfare)
}
inline std::string* Location_Placemark::mutable_thoroughfare() {
  std::string* _s = _internal_mutable_thoroughfare();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.thoroughfare)
  return _s;
}
inline const std::string& Location_Placemark::_internal_thoroughfare() const {
  return thoroughfare_.Get();
}
inline void Location_Placemark::_internal_set_thoroughfare(const std::string& value) {
  
  thoroughfare_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_thoroughfare() {
  
  return thoroughfare_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_thoroughfare() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.thoroughfare)
  return thoroughfare_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_thoroughfare(std::string* thoroughfare) {
  if (thoroughfare != nullptr) {
    
  } else {
    
  }
  thoroughfare_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thoroughfare,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thoroughfare_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thoroughfare_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.thoroughfare)
}

// string sub_thoroughfare = 11 [json_name = "subThoroughfare"];
inline void Location_Placemark::clear_sub_thoroughfare() {
  sub_thoroughfare_.ClearToEmpty();
}
inline const std::string& Location_Placemark::sub_thoroughfare() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.Placemark.sub_thoroughfare)
  return _internal_sub_thoroughfare();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Location_Placemark::set_sub_thoroughfare(ArgT0&& arg0, ArgT... args) {
 
 sub_thoroughfare_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Location.Placemark.sub_thoroughfare)
}
inline std::string* Location_Placemark::mutable_sub_thoroughfare() {
  std::string* _s = _internal_mutable_sub_thoroughfare();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.Placemark.sub_thoroughfare)
  return _s;
}
inline const std::string& Location_Placemark::_internal_sub_thoroughfare() const {
  return sub_thoroughfare_.Get();
}
inline void Location_Placemark::_internal_set_sub_thoroughfare(const std::string& value) {
  
  sub_thoroughfare_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Location_Placemark::_internal_mutable_sub_thoroughfare() {
  
  return sub_thoroughfare_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Location_Placemark::release_sub_thoroughfare() {
  // @@protoc_insertion_point(field_release:common.v1.Location.Placemark.sub_thoroughfare)
  return sub_thoroughfare_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Location_Placemark::set_allocated_sub_thoroughfare(std::string* sub_thoroughfare) {
  if (sub_thoroughfare != nullptr) {
    
  } else {
    
  }
  sub_thoroughfare_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sub_thoroughfare,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sub_thoroughfare_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sub_thoroughfare_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.Placemark.sub_thoroughfare)
}

// -------------------------------------------------------------------

// Location

// double latitude = 1 [json_name = "latitude"];
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline double Location::_internal_latitude() const {
  return latitude_;
}
inline double Location::latitude() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.latitude)
  return _internal_latitude();
}
inline void Location::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void Location::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:common.v1.Location.latitude)
}

// double longitude = 2 [json_name = "longitude"];
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline double Location::_internal_longitude() const {
  return longitude_;
}
inline double Location::longitude() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.longitude)
  return _internal_longitude();
}
inline void Location::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void Location::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:common.v1.Location.longitude)
}

// .common.v1.Location.Placemark placemark = 3 [json_name = "placemark"];
inline bool Location::_internal_has_placemark() const {
  return this != internal_default_instance() && placemark_ != nullptr;
}
inline bool Location::has_placemark() const {
  return _internal_has_placemark();
}
inline void Location::clear_placemark() {
  if (GetArenaForAllocation() == nullptr && placemark_ != nullptr) {
    delete placemark_;
  }
  placemark_ = nullptr;
}
inline const ::common::v1::Location_Placemark& Location::_internal_placemark() const {
  const ::common::v1::Location_Placemark* p = placemark_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Location_Placemark&>(
      ::common::v1::_Location_Placemark_default_instance_);
}
inline const ::common::v1::Location_Placemark& Location::placemark() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.placemark)
  return _internal_placemark();
}
inline void Location::unsafe_arena_set_allocated_placemark(
    ::common::v1::Location_Placemark* placemark) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(placemark_);
  }
  placemark_ = placemark;
  if (placemark) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Location.placemark)
}
inline ::common::v1::Location_Placemark* Location::release_placemark() {
  
  ::common::v1::Location_Placemark* temp = placemark_;
  placemark_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Location_Placemark* Location::unsafe_arena_release_placemark() {
  // @@protoc_insertion_point(field_release:common.v1.Location.placemark)
  
  ::common::v1::Location_Placemark* temp = placemark_;
  placemark_ = nullptr;
  return temp;
}
inline ::common::v1::Location_Placemark* Location::_internal_mutable_placemark() {
  
  if (placemark_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Location_Placemark>(GetArenaForAllocation());
    placemark_ = p;
  }
  return placemark_;
}
inline ::common::v1::Location_Placemark* Location::mutable_placemark() {
  ::common::v1::Location_Placemark* _msg = _internal_mutable_placemark();
  // @@protoc_insertion_point(field_mutable:common.v1.Location.placemark)
  return _msg;
}
inline void Location::set_allocated_placemark(::common::v1::Location_Placemark* placemark) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete placemark_;
  }
  if (placemark) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::Location_Placemark>::GetOwningArena(placemark);
    if (message_arena != submessage_arena) {
      placemark = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, placemark, submessage_arena);
    }
    
  } else {
    
  }
  placemark_ = placemark;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Location.placemark)
}

// int64 last_modified = 4 [json_name = "lastModified"];
inline void Location::clear_last_modified() {
  last_modified_ = int64_t{0};
}
inline int64_t Location::_internal_last_modified() const {
  return last_modified_;
}
inline int64_t Location::last_modified() const {
  // @@protoc_insertion_point(field_get:common.v1.Location.last_modified)
  return _internal_last_modified();
}
inline void Location::_internal_set_last_modified(int64_t value) {
  
  last_modified_ = value;
}
inline void Location::set_last_modified(int64_t value) {
  _internal_set_last_modified(value);
  // @@protoc_insertion_point(field_set:common.v1.Location.last_modified)
}

// -------------------------------------------------------------------

// Metadata

// int64 timestamp = 1 [json_name = "timestamp"];
inline void Metadata::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t Metadata::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t Metadata::timestamp() const {
  // @@protoc_insertion_point(field_get:common.v1.Metadata.timestamp)
  return _internal_timestamp();
}
inline void Metadata::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void Metadata::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:common.v1.Metadata.timestamp)
}

// string node_id = 2 [json_name = "nodeId"];
inline void Metadata::clear_node_id() {
  node_id_.ClearToEmpty();
}
inline const std::string& Metadata::node_id() const {
  // @@protoc_insertion_point(field_get:common.v1.Metadata.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Metadata.node_id)
}
inline std::string* Metadata::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:common.v1.Metadata.node_id)
  return _s;
}
inline const std::string& Metadata::_internal_node_id() const {
  return node_id_.Get();
}
inline void Metadata::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_node_id() {
  
  return node_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_node_id() {
  // @@protoc_insertion_point(field_release:common.v1.Metadata.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Metadata.node_id)
}

// bytes signature = 3 [json_name = "signature"];
inline void Metadata::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& Metadata::signature() const {
  // @@protoc_insertion_point(field_get:common.v1.Metadata.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Metadata.signature)
}
inline std::string* Metadata::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:common.v1.Metadata.signature)
  return _s;
}
inline const std::string& Metadata::_internal_signature() const {
  return signature_.Get();
}
inline void Metadata::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_signature() {
  // @@protoc_insertion_point(field_release:common.v1.Metadata.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Metadata.signature)
}

// bytes public_key = 4 [json_name = "publicKey"];
inline void Metadata::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& Metadata::public_key() const {
  // @@protoc_insertion_point(field_get:common.v1.Metadata.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Metadata.public_key)
}
inline std::string* Metadata::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:common.v1.Metadata.public_key)
  return _s;
}
inline const std::string& Metadata::_internal_public_key() const {
  return public_key_.Get();
}
inline void Metadata::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_public_key() {
  // @@protoc_insertion_point(field_release:common.v1.Metadata.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Metadata.public_key)
}

// -------------------------------------------------------------------

// MIME

// .common.v1.MIME.Type type = 1 [json_name = "type"];
inline void MIME::clear_type() {
  type_ = 0;
}
inline ::common::v1::MIME_Type MIME::_internal_type() const {
  return static_cast< ::common::v1::MIME_Type >(type_);
}
inline ::common::v1::MIME_Type MIME::type() const {
  // @@protoc_insertion_point(field_get:common.v1.MIME.type)
  return _internal_type();
}
inline void MIME::_internal_set_type(::common::v1::MIME_Type value) {
  
  type_ = value;
}
inline void MIME::set_type(::common::v1::MIME_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:common.v1.MIME.type)
}

// string subtype = 2 [json_name = "subtype"];
inline void MIME::clear_subtype() {
  subtype_.ClearToEmpty();
}
inline const std::string& MIME::subtype() const {
  // @@protoc_insertion_point(field_get:common.v1.MIME.subtype)
  return _internal_subtype();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MIME::set_subtype(ArgT0&& arg0, ArgT... args) {
 
 subtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.MIME.subtype)
}
inline std::string* MIME::mutable_subtype() {
  std::string* _s = _internal_mutable_subtype();
  // @@protoc_insertion_point(field_mutable:common.v1.MIME.subtype)
  return _s;
}
inline const std::string& MIME::_internal_subtype() const {
  return subtype_.Get();
}
inline void MIME::_internal_set_subtype(const std::string& value) {
  
  subtype_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MIME::_internal_mutable_subtype() {
  
  return subtype_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MIME::release_subtype() {
  // @@protoc_insertion_point(field_release:common.v1.MIME.subtype)
  return subtype_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MIME::set_allocated_subtype(std::string* subtype) {
  if (subtype != nullptr) {
    
  } else {
    
  }
  subtype_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), subtype,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subtype_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    subtype_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.MIME.subtype)
}

// string value = 3 [json_name = "value"];
inline void MIME::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& MIME::value() const {
  // @@protoc_insertion_point(field_get:common.v1.MIME.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MIME::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.MIME.value)
}
inline std::string* MIME::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:common.v1.MIME.value)
  return _s;
}
inline const std::string& MIME::_internal_value() const {
  return value_.Get();
}
inline void MIME::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MIME::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MIME::release_value() {
  // @@protoc_insertion_point(field_release:common.v1.MIME.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MIME::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.MIME.value)
}

// -------------------------------------------------------------------

// Peer_Device

// string id = 1 [json_name = "id"];
inline void Peer_Device::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Peer_Device::id() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.Device.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer_Device::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.Device.id)
}
inline std::string* Peer_Device::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.Device.id)
  return _s;
}
inline const std::string& Peer_Device::_internal_id() const {
  return id_.Get();
}
inline void Peer_Device::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer_Device::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer_Device::release_id() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.Device.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer_Device::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.Device.id)
}

// string host_name = 2 [json_name = "hostName"];
inline void Peer_Device::clear_host_name() {
  host_name_.ClearToEmpty();
}
inline const std::string& Peer_Device::host_name() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.Device.host_name)
  return _internal_host_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer_Device::set_host_name(ArgT0&& arg0, ArgT... args) {
 
 host_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.Device.host_name)
}
inline std::string* Peer_Device::mutable_host_name() {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.Device.host_name)
  return _s;
}
inline const std::string& Peer_Device::_internal_host_name() const {
  return host_name_.Get();
}
inline void Peer_Device::_internal_set_host_name(const std::string& value) {
  
  host_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer_Device::_internal_mutable_host_name() {
  
  return host_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer_Device::release_host_name() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.Device.host_name)
  return host_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer_Device::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    
  } else {
    
  }
  host_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.Device.host_name)
}

// string os = 3 [json_name = "os"];
inline void Peer_Device::clear_os() {
  os_.ClearToEmpty();
}
inline const std::string& Peer_Device::os() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.Device.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer_Device::set_os(ArgT0&& arg0, ArgT... args) {
 
 os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.Device.os)
}
inline std::string* Peer_Device::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.Device.os)
  return _s;
}
inline const std::string& Peer_Device::_internal_os() const {
  return os_.Get();
}
inline void Peer_Device::_internal_set_os(const std::string& value) {
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer_Device::_internal_mutable_os() {
  
  return os_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer_Device::release_os() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.Device.os)
  return os_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer_Device::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.Device.os)
}

// string arch = 4 [json_name = "arch"];
inline void Peer_Device::clear_arch() {
  arch_.ClearToEmpty();
}
inline const std::string& Peer_Device::arch() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.Device.arch)
  return _internal_arch();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer_Device::set_arch(ArgT0&& arg0, ArgT... args) {
 
 arch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.Device.arch)
}
inline std::string* Peer_Device::mutable_arch() {
  std::string* _s = _internal_mutable_arch();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.Device.arch)
  return _s;
}
inline const std::string& Peer_Device::_internal_arch() const {
  return arch_.Get();
}
inline void Peer_Device::_internal_set_arch(const std::string& value) {
  
  arch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer_Device::_internal_mutable_arch() {
  
  return arch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer_Device::release_arch() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.Device.arch)
  return arch_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer_Device::set_allocated_arch(std::string* arch) {
  if (arch != nullptr) {
    
  } else {
    
  }
  arch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), arch,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (arch_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    arch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.Device.arch)
}

// string model = 5 [json_name = "model"];
inline void Peer_Device::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& Peer_Device::model() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.Device.model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer_Device::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.Device.model)
}
inline std::string* Peer_Device::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.Device.model)
  return _s;
}
inline const std::string& Peer_Device::_internal_model() const {
  return model_.Get();
}
inline void Peer_Device::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer_Device::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer_Device::release_model() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.Device.model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer_Device::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.Device.model)
}

// -------------------------------------------------------------------

// Peer

// string s_name = 1 [json_name = "sName"];
inline void Peer::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& Peer::s_name() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.s_name)
}
inline std::string* Peer::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.s_name)
  return _s;
}
inline const std::string& Peer::_internal_s_name() const {
  return s_name_.Get();
}
inline void Peer::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer::release_s_name() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.s_name)
}

// .common.v1.Peer.Status status = 2 [json_name = "status"];
inline void Peer::clear_status() {
  status_ = 0;
}
inline ::common::v1::Peer_Status Peer::_internal_status() const {
  return static_cast< ::common::v1::Peer_Status >(status_);
}
inline ::common::v1::Peer_Status Peer::status() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.status)
  return _internal_status();
}
inline void Peer::_internal_set_status(::common::v1::Peer_Status value) {
  
  status_ = value;
}
inline void Peer::set_status(::common::v1::Peer_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:common.v1.Peer.status)
}

// .common.v1.Peer.Device device = 3 [json_name = "device"];
inline bool Peer::_internal_has_device() const {
  return this != internal_default_instance() && device_ != nullptr;
}
inline bool Peer::has_device() const {
  return _internal_has_device();
}
inline void Peer::clear_device() {
  if (GetArenaForAllocation() == nullptr && device_ != nullptr) {
    delete device_;
  }
  device_ = nullptr;
}
inline const ::common::v1::Peer_Device& Peer::_internal_device() const {
  const ::common::v1::Peer_Device* p = device_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Peer_Device&>(
      ::common::v1::_Peer_Device_default_instance_);
}
inline const ::common::v1::Peer_Device& Peer::device() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.device)
  return _internal_device();
}
inline void Peer::unsafe_arena_set_allocated_device(
    ::common::v1::Peer_Device* device) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_);
  }
  device_ = device;
  if (device) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Peer.device)
}
inline ::common::v1::Peer_Device* Peer::release_device() {
  
  ::common::v1::Peer_Device* temp = device_;
  device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Peer_Device* Peer::unsafe_arena_release_device() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.device)
  
  ::common::v1::Peer_Device* temp = device_;
  device_ = nullptr;
  return temp;
}
inline ::common::v1::Peer_Device* Peer::_internal_mutable_device() {
  
  if (device_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Peer_Device>(GetArenaForAllocation());
    device_ = p;
  }
  return device_;
}
inline ::common::v1::Peer_Device* Peer::mutable_device() {
  ::common::v1::Peer_Device* _msg = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.device)
  return _msg;
}
inline void Peer::set_allocated_device(::common::v1::Peer_Device* device) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_;
  }
  if (device) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::Peer_Device>::GetOwningArena(device);
    if (message_arena != submessage_arena) {
      device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device, submessage_arena);
    }
    
  } else {
    
  }
  device_ = device;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.device)
}

// .common.v1.Profile profile = 4 [json_name = "profile"];
inline bool Peer::_internal_has_profile() const {
  return this != internal_default_instance() && profile_ != nullptr;
}
inline bool Peer::has_profile() const {
  return _internal_has_profile();
}
inline void Peer::clear_profile() {
  if (GetArenaForAllocation() == nullptr && profile_ != nullptr) {
    delete profile_;
  }
  profile_ = nullptr;
}
inline const ::common::v1::Profile& Peer::_internal_profile() const {
  const ::common::v1::Profile* p = profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Profile&>(
      ::common::v1::_Profile_default_instance_);
}
inline const ::common::v1::Profile& Peer::profile() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.profile)
  return _internal_profile();
}
inline void Peer::unsafe_arena_set_allocated_profile(
    ::common::v1::Profile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile_);
  }
  profile_ = profile;
  if (profile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Peer.profile)
}
inline ::common::v1::Profile* Peer::release_profile() {
  
  ::common::v1::Profile* temp = profile_;
  profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Profile* Peer::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.profile)
  
  ::common::v1::Profile* temp = profile_;
  profile_ = nullptr;
  return temp;
}
inline ::common::v1::Profile* Peer::_internal_mutable_profile() {
  
  if (profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Profile>(GetArenaForAllocation());
    profile_ = p;
  }
  return profile_;
}
inline ::common::v1::Profile* Peer::mutable_profile() {
  ::common::v1::Profile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.profile)
  return _msg;
}
inline void Peer::set_allocated_profile(::common::v1::Profile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete profile_;
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::Profile>::GetOwningArena(profile);
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    
  } else {
    
  }
  profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.profile)
}

// bytes public_key = 5 [json_name = "publicKey"];
inline void Peer::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& Peer::public_key() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.public_key)
}
inline std::string* Peer::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.public_key)
  return _s;
}
inline const std::string& Peer::_internal_public_key() const {
  return public_key_.Get();
}
inline void Peer::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer::release_public_key() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.public_key)
}

// string peer_id = 6 [json_name = "peerId"];
inline void Peer::clear_peer_id() {
  peer_id_.ClearToEmpty();
}
inline const std::string& Peer::peer_id() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.peer_id)
  return _internal_peer_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Peer::set_peer_id(ArgT0&& arg0, ArgT... args) {
 
 peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Peer.peer_id)
}
inline std::string* Peer::mutable_peer_id() {
  std::string* _s = _internal_mutable_peer_id();
  // @@protoc_insertion_point(field_mutable:common.v1.Peer.peer_id)
  return _s;
}
inline const std::string& Peer::_internal_peer_id() const {
  return peer_id_.Get();
}
inline void Peer::_internal_set_peer_id(const std::string& value) {
  
  peer_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Peer::_internal_mutable_peer_id() {
  
  return peer_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Peer::release_peer_id() {
  // @@protoc_insertion_point(field_release:common.v1.Peer.peer_id)
  return peer_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Peer::set_allocated_peer_id(std::string* peer_id) {
  if (peer_id != nullptr) {
    
  } else {
    
  }
  peer_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Peer.peer_id)
}

// int64 last_modified = 7 [json_name = "lastModified"];
inline void Peer::clear_last_modified() {
  last_modified_ = int64_t{0};
}
inline int64_t Peer::_internal_last_modified() const {
  return last_modified_;
}
inline int64_t Peer::last_modified() const {
  // @@protoc_insertion_point(field_get:common.v1.Peer.last_modified)
  return _internal_last_modified();
}
inline void Peer::_internal_set_last_modified(int64_t value) {
  
  last_modified_ = value;
}
inline void Peer::set_last_modified(int64_t value) {
  _internal_set_last_modified(value);
  // @@protoc_insertion_point(field_set:common.v1.Peer.last_modified)
}

// -------------------------------------------------------------------

// Profile

// string s_name = 1 [json_name = "sName"];
inline void Profile::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& Profile::s_name() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Profile.s_name)
}
inline std::string* Profile::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.s_name)
  return _s;
}
inline const std::string& Profile::_internal_s_name() const {
  return s_name_.Get();
}
inline void Profile::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Profile::release_s_name() {
  // @@protoc_insertion_point(field_release:common.v1.Profile.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Profile::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Profile.s_name)
}

// string first_name = 2 [json_name = "firstName"];
inline void Profile::clear_first_name() {
  first_name_.ClearToEmpty();
}
inline const std::string& Profile::first_name() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_first_name(ArgT0&& arg0, ArgT... args) {
 
 first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Profile.first_name)
}
inline std::string* Profile::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.first_name)
  return _s;
}
inline const std::string& Profile::_internal_first_name() const {
  return first_name_.Get();
}
inline void Profile::_internal_set_first_name(const std::string& value) {
  
  first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_first_name() {
  
  return first_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Profile::release_first_name() {
  // @@protoc_insertion_point(field_release:common.v1.Profile.first_name)
  return first_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Profile::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    
  } else {
    
  }
  first_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Profile.first_name)
}

// string last_name = 3 [json_name = "lastName"];
inline void Profile::clear_last_name() {
  last_name_.ClearToEmpty();
}
inline const std::string& Profile::last_name() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_last_name(ArgT0&& arg0, ArgT... args) {
 
 last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Profile.last_name)
}
inline std::string* Profile::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.last_name)
  return _s;
}
inline const std::string& Profile::_internal_last_name() const {
  return last_name_.Get();
}
inline void Profile::_internal_set_last_name(const std::string& value) {
  
  last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_last_name() {
  
  return last_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Profile::release_last_name() {
  // @@protoc_insertion_point(field_release:common.v1.Profile.last_name)
  return last_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Profile::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    
  } else {
    
  }
  last_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Profile.last_name)
}

// bytes picture = 4 [json_name = "picture"];
inline void Profile::clear_picture() {
  picture_.ClearToEmpty();
}
inline const std::string& Profile::picture() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.picture)
  return _internal_picture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_picture(ArgT0&& arg0, ArgT... args) {
 
 picture_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Profile.picture)
}
inline std::string* Profile::mutable_picture() {
  std::string* _s = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.picture)
  return _s;
}
inline const std::string& Profile::_internal_picture() const {
  return picture_.Get();
}
inline void Profile::_internal_set_picture(const std::string& value) {
  
  picture_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_picture() {
  
  return picture_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Profile::release_picture() {
  // @@protoc_insertion_point(field_release:common.v1.Profile.picture)
  return picture_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Profile::set_allocated_picture(std::string* picture) {
  if (picture != nullptr) {
    
  } else {
    
  }
  picture_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), picture,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (picture_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    picture_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Profile.picture)
}

// string bio = 6 [json_name = "bio"];
inline void Profile::clear_bio() {
  bio_.ClearToEmpty();
}
inline const std::string& Profile::bio() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.bio)
  return _internal_bio();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Profile::set_bio(ArgT0&& arg0, ArgT... args) {
 
 bio_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Profile.bio)
}
inline std::string* Profile::mutable_bio() {
  std::string* _s = _internal_mutable_bio();
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.bio)
  return _s;
}
inline const std::string& Profile::_internal_bio() const {
  return bio_.Get();
}
inline void Profile::_internal_set_bio(const std::string& value) {
  
  bio_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Profile::_internal_mutable_bio() {
  
  return bio_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Profile::release_bio() {
  // @@protoc_insertion_point(field_release:common.v1.Profile.bio)
  return bio_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Profile::set_allocated_bio(std::string* bio) {
  if (bio != nullptr) {
    
  } else {
    
  }
  bio_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bio,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bio_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bio_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Profile.bio)
}

// repeated .common.v1.Social socials = 7 [json_name = "socials"];
inline int Profile::_internal_socials_size() const {
  return socials_.size();
}
inline int Profile::socials_size() const {
  return _internal_socials_size();
}
inline void Profile::clear_socials() {
  socials_.Clear();
}
inline ::common::v1::Social* Profile::mutable_socials(int index) {
  // @@protoc_insertion_point(field_mutable:common.v1.Profile.socials)
  return socials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Social >*
Profile::mutable_socials() {
  // @@protoc_insertion_point(field_mutable_list:common.v1.Profile.socials)
  return &socials_;
}
inline const ::common::v1::Social& Profile::_internal_socials(int index) const {
  return socials_.Get(index);
}
inline const ::common::v1::Social& Profile::socials(int index) const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.socials)
  return _internal_socials(index);
}
inline ::common::v1::Social* Profile::_internal_add_socials() {
  return socials_.Add();
}
inline ::common::v1::Social* Profile::add_socials() {
  ::common::v1::Social* _add = _internal_add_socials();
  // @@protoc_insertion_point(field_add:common.v1.Profile.socials)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Social >&
Profile::socials() const {
  // @@protoc_insertion_point(field_list:common.v1.Profile.socials)
  return socials_;
}

// int64 last_modified = 8 [json_name = "lastModified"];
inline void Profile::clear_last_modified() {
  last_modified_ = int64_t{0};
}
inline int64_t Profile::_internal_last_modified() const {
  return last_modified_;
}
inline int64_t Profile::last_modified() const {
  // @@protoc_insertion_point(field_get:common.v1.Profile.last_modified)
  return _internal_last_modified();
}
inline void Profile::_internal_set_last_modified(int64_t value) {
  
  last_modified_ = value;
}
inline void Profile::set_last_modified(int64_t value) {
  _internal_set_last_modified(value);
  // @@protoc_insertion_point(field_set:common.v1.Profile.last_modified)
}

// -------------------------------------------------------------------

// ProfileList

// repeated .common.v1.Profile profiles = 1 [json_name = "profiles"];
inline int ProfileList::_internal_profiles_size() const {
  return profiles_.size();
}
inline int ProfileList::profiles_size() const {
  return _internal_profiles_size();
}
inline void ProfileList::clear_profiles() {
  profiles_.Clear();
}
inline ::common::v1::Profile* ProfileList::mutable_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:common.v1.ProfileList.profiles)
  return profiles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Profile >*
ProfileList::mutable_profiles() {
  // @@protoc_insertion_point(field_mutable_list:common.v1.ProfileList.profiles)
  return &profiles_;
}
inline const ::common::v1::Profile& ProfileList::_internal_profiles(int index) const {
  return profiles_.Get(index);
}
inline const ::common::v1::Profile& ProfileList::profiles(int index) const {
  // @@protoc_insertion_point(field_get:common.v1.ProfileList.profiles)
  return _internal_profiles(index);
}
inline ::common::v1::Profile* ProfileList::_internal_add_profiles() {
  return profiles_.Add();
}
inline ::common::v1::Profile* ProfileList::add_profiles() {
  ::common::v1::Profile* _add = _internal_add_profiles();
  // @@protoc_insertion_point(field_add:common.v1.ProfileList.profiles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Profile >&
ProfileList::profiles() const {
  // @@protoc_insertion_point(field_list:common.v1.ProfileList.profiles)
  return profiles_;
}

// int64 created_at = 2 [json_name = "createdAt"];
inline void ProfileList::clear_created_at() {
  created_at_ = int64_t{0};
}
inline int64_t ProfileList::_internal_created_at() const {
  return created_at_;
}
inline int64_t ProfileList::created_at() const {
  // @@protoc_insertion_point(field_get:common.v1.ProfileList.created_at)
  return _internal_created_at();
}
inline void ProfileList::_internal_set_created_at(int64_t value) {
  
  created_at_ = value;
}
inline void ProfileList::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:common.v1.ProfileList.created_at)
}

// string key = 3 [json_name = "key"];
inline void ProfileList::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& ProfileList::key() const {
  // @@protoc_insertion_point(field_get:common.v1.ProfileList.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProfileList::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ProfileList.key)
}
inline std::string* ProfileList::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:common.v1.ProfileList.key)
  return _s;
}
inline const std::string& ProfileList::_internal_key() const {
  return key_.Get();
}
inline void ProfileList::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProfileList::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProfileList::release_key() {
  // @@protoc_insertion_point(field_release:common.v1.ProfileList.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProfileList::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ProfileList.key)
}

// int64 last_modified = 4 [json_name = "lastModified"];
inline void ProfileList::clear_last_modified() {
  last_modified_ = int64_t{0};
}
inline int64_t ProfileList::_internal_last_modified() const {
  return last_modified_;
}
inline int64_t ProfileList::last_modified() const {
  // @@protoc_insertion_point(field_get:common.v1.ProfileList.last_modified)
  return _internal_last_modified();
}
inline void ProfileList::_internal_set_last_modified(int64_t value) {
  
  last_modified_ = value;
}
inline void ProfileList::set_last_modified(int64_t value) {
  _internal_set_last_modified(value);
  // @@protoc_insertion_point(field_set:common.v1.ProfileList.last_modified)
}

// -------------------------------------------------------------------

// Social

// bool valid = 1 [json_name = "valid"];
inline void Social::clear_valid() {
  valid_ = false;
}
inline bool Social::_internal_valid() const {
  return valid_;
}
inline bool Social::valid() const {
  // @@protoc_insertion_point(field_get:common.v1.Social.valid)
  return _internal_valid();
}
inline void Social::_internal_set_valid(bool value) {
  
  valid_ = value;
}
inline void Social::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:common.v1.Social.valid)
}

// string username = 2 [json_name = "username"];
inline void Social::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& Social::username() const {
  // @@protoc_insertion_point(field_get:common.v1.Social.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Social::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Social.username)
}
inline std::string* Social::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:common.v1.Social.username)
  return _s;
}
inline const std::string& Social::_internal_username() const {
  return username_.Get();
}
inline void Social::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Social::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Social::release_username() {
  // @@protoc_insertion_point(field_release:common.v1.Social.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Social::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Social.username)
}

// string url = 3 [json_name = "url"];
inline void Social::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Social::url() const {
  // @@protoc_insertion_point(field_get:common.v1.Social.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Social::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Social.url)
}
inline std::string* Social::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:common.v1.Social.url)
  return _s;
}
inline const std::string& Social::_internal_url() const {
  return url_.Get();
}
inline void Social::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Social::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Social::release_url() {
  // @@protoc_insertion_point(field_release:common.v1.Social.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Social::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Social.url)
}

// bytes picture = 4 [json_name = "picture"];
inline void Social::clear_picture() {
  picture_.ClearToEmpty();
}
inline const std::string& Social::picture() const {
  // @@protoc_insertion_point(field_get:common.v1.Social.picture)
  return _internal_picture();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Social::set_picture(ArgT0&& arg0, ArgT... args) {
 
 picture_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.Social.picture)
}
inline std::string* Social::mutable_picture() {
  std::string* _s = _internal_mutable_picture();
  // @@protoc_insertion_point(field_mutable:common.v1.Social.picture)
  return _s;
}
inline const std::string& Social::_internal_picture() const {
  return picture_.Get();
}
inline void Social::_internal_set_picture(const std::string& value) {
  
  picture_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Social::_internal_mutable_picture() {
  
  return picture_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Social::release_picture() {
  // @@protoc_insertion_point(field_release:common.v1.Social.picture)
  return picture_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Social::set_allocated_picture(std::string* picture) {
  if (picture != nullptr) {
    
  } else {
    
  }
  picture_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), picture,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (picture_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    picture_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.Social.picture)
}

// .common.v1.Social.Media media = 5 [json_name = "media"];
inline void Social::clear_media() {
  media_ = 0;
}
inline ::common::v1::Social_Media Social::_internal_media() const {
  return static_cast< ::common::v1::Social_Media >(media_);
}
inline ::common::v1::Social_Media Social::media() const {
  // @@protoc_insertion_point(field_get:common.v1.Social.media)
  return _internal_media();
}
inline void Social::_internal_set_media(::common::v1::Social_Media value) {
  
  media_ = value;
}
inline void Social::set_media(::common::v1::Social_Media value) {
  _internal_set_media(value);
  // @@protoc_insertion_point(field_set:common.v1.Social.media)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace common

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::common::v1::MIME_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::v1::MIME_Type>() {
  return ::common::v1::MIME_Type_descriptor();
}
template <> struct is_proto_enum< ::common::v1::Peer_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::v1::Peer_Status>() {
  return ::common::v1::Peer_Status_descriptor();
}
template <> struct is_proto_enum< ::common::v1::Social_Media> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::v1::Social_Media>() {
  return ::common::v1::Social_Media_descriptor();
}
template <> struct is_proto_enum< ::common::v1::Connection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::v1::Connection>() {
  return ::common::v1::Connection_descriptor();
}
template <> struct is_proto_enum< ::common::v1::Environment> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::common::v1::Environment>() {
  return ::common::v1::Environment_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fcore_2eproto
