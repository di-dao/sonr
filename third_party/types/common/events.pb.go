// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/v1/events.proto

// Package Motor is used for defining a Motor node and its properties.

package common

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// defines actions performed during wallet creation
type WALLET_EVENT_TYPE int32

const (
	WALLET_EVENT_TYPE_UNKNOWN WALLET_EVENT_TYPE = 0
	// triggered when did document is created for the new address.
	WALLET_EVENT_TYPE_DID_DOCUMENT_CREATE_START WALLET_EVENT_TYPE = 1
	// triggered when assertion method is created and the pk is associated with the document.
	WALLET_EVENT_TYPE_DID_DOCUMENT_CREATE_END WALLET_EVENT_TYPE = 2
	// triggered if did document creation has an error errorMessage will be populated
	WALLET_EVENT_TYPE_DID_DOCUMENT_CREATE_ERROR WALLET_EVENT_TYPE = 3
	// triggered when PSK and DSC keys are being created. Only fires for CreateAccount
	// fires on the the start of DSC creation
	WALLET_EVENT_TYPE_KEY_CREATE_START WALLET_EVENT_TYPE = 4
	// triggered when both the PSK and DSC keys are done generating.  Only fires for CreateAccount
	WALLET_EVENT_TYPE_KEY_CREATE_END WALLET_EVENT_TYPE = 5
	// triggered when key create has an error errorMessage will be populated
	WALLET_EVENT_TYPE_KEY_CREATE_ERROR WALLET_EVENT_TYPE = 6
	// triggered on start of PSK and DSC singing
	WALLET_EVENT_TYPE_KEY_ENCRYPT_START WALLET_EVENT_TYPE = 7
	// triggered on end of PSK and DSC singning
	WALLET_EVENT_TYPE_KEY_ENCRYPT_END WALLET_EVENT_TYPE = 8
	// triggered if key encrypt has an error.
	WALLET_EVENT_TYPE_KEY_ENCRYPT_ERROR WALLET_EVENT_TYPE = 9
	// triggered before intial token faucet occurs to the new address.
	WALLET_EVENT_TYPE_FAUCET_REQUEST_START WALLET_EVENT_TYPE = 10
	// triggered after a response from faucet request is recieved.
	WALLET_EVENT_TYPE_FAUCET_REQUEST_END WALLET_EVENT_TYPE = 11
	// triggered if fauceting has an error errorMessage will be populated
	WALLET_EVENT_TYPE_FAUCET_REQUEST_ERROR WALLET_EVENT_TYPE = 12
	// triggered on inital shard creation start
	WALLET_EVENT_TYPE_SHARD_GENERATE_START WALLET_EVENT_TYPE = 13
	// triggered on inital shard generation end.
	WALLET_EVENT_TYPE_SHARD_GENERATE_END WALLET_EVENT_TYPE = 14
	// triggered if shard generation has an error errorMessage will be populated
	WALLET_EVENT_TYPE_SHARD_GENERATE_ERROR WALLET_EVENT_TYPE = 15
	// triggered on start of WhoIs creation
	WALLET_EVENT_TYPE_WHO_IS_CREATE_START WALLET_EVENT_TYPE = 16
	// triggered when WhoIs creation ends
	WALLET_EVENT_TYPE_WHO_IS_CREATE_END WALLET_EVENT_TYPE = 17
	// triggered when WhoIs creation errors
	WALLET_EVENT_TYPE_WHO_IS_CREATE_ERROR WALLET_EVENT_TYPE = 18
	// triggered when the vault is being created.
	WALLET_EVENT_TYPE_VAULT_CREATE_START WALLET_EVENT_TYPE = 19
	// triggered after vault creation has returned.
	// if an error occurs it will be within the event
	WALLET_EVENT_TYPE_VAULT_CREATE_END WALLET_EVENT_TYPE = 20
	// triggered if vault create has an error populates errorMessage
	WALLET_EVENT_TYPE_VAULT_CREATE_ERROR WALLET_EVENT_TYPE = 21
)

var WALLET_EVENT_TYPE_name = map[int32]string{
	0:  "UNKNOWN",
	1:  "DID_DOCUMENT_CREATE_START",
	2:  "DID_DOCUMENT_CREATE_END",
	3:  "DID_DOCUMENT_CREATE_ERROR",
	4:  "KEY_CREATE_START",
	5:  "KEY_CREATE_END",
	6:  "KEY_CREATE_ERROR",
	7:  "KEY_ENCRYPT_START",
	8:  "KEY_ENCRYPT_END",
	9:  "KEY_ENCRYPT_ERROR",
	10: "FAUCET_REQUEST_START",
	11: "FAUCET_REQUEST_END",
	12: "FAUCET_REQUEST_ERROR",
	13: "SHARD_GENERATE_START",
	14: "SHARD_GENERATE_END",
	15: "SHARD_GENERATE_ERROR",
	16: "WHO_IS_CREATE_START",
	17: "WHO_IS_CREATE_END",
	18: "WHO_IS_CREATE_ERROR",
	19: "VAULT_CREATE_START",
	20: "VAULT_CREATE_END",
	21: "VAULT_CREATE_ERROR",
}

var WALLET_EVENT_TYPE_value = map[string]int32{
	"UNKNOWN":                   0,
	"DID_DOCUMENT_CREATE_START": 1,
	"DID_DOCUMENT_CREATE_END":   2,
	"DID_DOCUMENT_CREATE_ERROR": 3,
	"KEY_CREATE_START":          4,
	"KEY_CREATE_END":            5,
	"KEY_CREATE_ERROR":          6,
	"KEY_ENCRYPT_START":         7,
	"KEY_ENCRYPT_END":           8,
	"KEY_ENCRYPT_ERROR":         9,
	"FAUCET_REQUEST_START":      10,
	"FAUCET_REQUEST_END":        11,
	"FAUCET_REQUEST_ERROR":      12,
	"SHARD_GENERATE_START":      13,
	"SHARD_GENERATE_END":        14,
	"SHARD_GENERATE_ERROR":      15,
	"WHO_IS_CREATE_START":       16,
	"WHO_IS_CREATE_END":         17,
	"WHO_IS_CREATE_ERROR":       18,
	"VAULT_CREATE_START":        19,
	"VAULT_CREATE_END":          20,
	"VAULT_CREATE_ERROR":        21,
}

func (x WALLET_EVENT_TYPE) String() string {
	return proto.EnumName(WALLET_EVENT_TYPE_name, int32(x))
}

func (WALLET_EVENT_TYPE) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8f835c9211202b0e, []int{0}
}

type WalletEvent struct {
	// context on what part of the wallet creation process is occuring
	Type WALLET_EVENT_TYPE `protobuf:"varint,1,opt,name=type,proto3,enum=sonrio.common.v1.WALLET_EVENT_TYPE" json:"type,omitempty"`
	// populated if an error has occured, type will denote an error
	ErrorMessage string `protobuf:"bytes,2,opt,name=errorMessage,proto3" json:"errorMessage,omitempty"`
	// status message. does not have to be populated
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Address of the wallet that is being created
	Address string `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *WalletEvent) Reset()         { *m = WalletEvent{} }
func (m *WalletEvent) String() string { return proto.CompactTextString(m) }
func (*WalletEvent) ProtoMessage()    {}
func (*WalletEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_8f835c9211202b0e, []int{0}
}
func (m *WalletEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletEvent.Merge(m, src)
}
func (m *WalletEvent) XXX_Size() int {
	return m.Size()
}
func (m *WalletEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletEvent.DiscardUnknown(m)
}

var xxx_messageInfo_WalletEvent proto.InternalMessageInfo

func (m *WalletEvent) GetType() WALLET_EVENT_TYPE {
	if m != nil {
		return m.Type
	}
	return WALLET_EVENT_TYPE_UNKNOWN
}

func (m *WalletEvent) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *WalletEvent) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *WalletEvent) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("sonrio.common.v1.WALLET_EVENT_TYPE", WALLET_EVENT_TYPE_name, WALLET_EVENT_TYPE_value)
	proto.RegisterType((*WalletEvent)(nil), "sonrio.common.v1.WalletEvent")
}

func init() { proto.RegisterFile("common/v1/events.proto", fileDescriptor_8f835c9211202b0e) }

var fileDescriptor_8f835c9211202b0e = []byte{
	// 461 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0xe3, 0x36, 0x34, 0x74, 0x52, 0x52, 0x67, 0x92, 0xb6, 0x46, 0x08, 0xab, 0x2a, 0x97,
	0x0a, 0x09, 0x9b, 0xc2, 0x81, 0xb3, 0x89, 0x07, 0x5a, 0x9a, 0x3a, 0x65, 0x63, 0x37, 0x0a, 0x17,
	0x2b, 0x25, 0x56, 0x1b, 0xa9, 0x89, 0xa3, 0xb5, 0x89, 0xd4, 0xb7, 0xe0, 0x09, 0xb8, 0xf1, 0x2e,
	0x1c, 0x7b, 0xe4, 0x88, 0x92, 0x17, 0x41, 0x93, 0x4d, 0x45, 0xed, 0x84, 0x93, 0xb5, 0xff, 0x8f,
	0xdf, 0x6a, 0xd7, 0xb3, 0xb0, 0xfb, 0x35, 0x1e, 0x0e, 0xe3, 0x91, 0x3d, 0x39, 0xb2, 0xa3, 0x49,
	0x34, 0x4a, 0x13, 0x6b, 0x2c, 0xe3, 0x34, 0x46, 0x3d, 0x89, 0x47, 0x72, 0x10, 0x5b, 0xca, 0xb6,
	0x26, 0x47, 0x07, 0x3f, 0x34, 0x28, 0x77, 0x7a, 0x37, 0x37, 0x51, 0x4a, 0x1c, 0xc4, 0x77, 0x50,
	0x4c, 0x6f, 0xc7, 0x91, 0xa1, 0xed, 0x6b, 0x87, 0x95, 0x37, 0x2f, 0xac, 0x7c, 0xc1, 0xea, 0x38,
	0xcd, 0x26, 0xf9, 0x21, 0x5d, 0x90, 0xe7, 0x87, 0x7e, 0xf7, 0x9c, 0xc4, 0xbc, 0x80, 0x07, 0xb0,
	0x15, 0x49, 0x19, 0xcb, 0xb3, 0x28, 0x49, 0x7a, 0x57, 0x91, 0xb1, 0xb6, 0xaf, 0x1d, 0x6e, 0x8a,
	0x8c, 0x86, 0x06, 0x94, 0x86, 0x0b, 0x7b, 0x7d, 0x6e, 0xdf, 0x2f, 0xd9, 0xe9, 0xf5, 0xfb, 0x32,
	0x4a, 0x12, 0xa3, 0xa8, 0x9c, 0xc5, 0xf2, 0xe5, 0xcf, 0x22, 0x54, 0x97, 0xf6, 0xc4, 0x32, 0x94,
	0x02, 0xef, 0xd4, 0x6b, 0x75, 0x3c, 0xbd, 0x80, 0xcf, 0xe1, 0xa9, 0x7b, 0xe2, 0x86, 0x6e, 0xab,
	0x11, 0x9c, 0x71, 0xa2, 0x21, 0xc8, 0xf1, 0x29, 0x6c, 0xfb, 0x8e, 0xf0, 0x75, 0x0d, 0x9f, 0xc1,
	0xde, 0x2a, 0x9b, 0x3c, 0x57, 0x5f, 0xfb, 0x5f, 0x97, 0x84, 0x68, 0x09, 0x7d, 0x1d, 0xeb, 0xa0,
	0x9f, 0x52, 0x37, 0x4b, 0x2c, 0x22, 0x42, 0xe5, 0x81, 0xca, 0xa0, 0x47, 0xb9, 0xa4, 0xea, 0x6f,
	0xe0, 0x0e, 0x54, 0x59, 0x25, 0xaf, 0x21, 0xba, 0xe7, 0xfe, 0x02, 0x50, 0xc2, 0x1a, 0x6c, 0x3f,
	0x94, 0x99, 0xf0, 0x38, 0x9f, 0x55, 0x88, 0x4d, 0x34, 0xa0, 0xfe, 0xc1, 0x09, 0x1a, 0xe4, 0x87,
	0x82, 0x3e, 0x07, 0xd4, 0xbe, 0xa7, 0x00, 0xee, 0x02, 0xe6, 0x1c, 0x06, 0x95, 0x57, 0x34, 0x14,
	0x6b, 0x8b, 0x9d, 0xf6, 0xb1, 0x23, 0xdc, 0xf0, 0x23, 0x79, 0x24, 0xfe, 0x1d, 0xe9, 0x09, 0xb3,
	0x72, 0x0e, 0xb3, 0x2a, 0x2b, 0x1a, 0x8a, 0xb5, 0x8d, 0x7b, 0x50, 0xeb, 0x1c, 0xb7, 0xc2, 0x93,
	0x76, 0xf6, 0x76, 0x74, 0x3e, 0x47, 0xd6, 0x60, 0x52, 0x75, 0x39, 0xaf, 0x40, 0xc8, 0x5b, 0x5f,
	0x38, 0x41, 0x33, 0xf7, 0xdf, 0x6a, 0x7c, 0xa3, 0x19, 0x9d, 0x31, 0xf5, 0xa5, 0xb4, 0xa2, 0xec,
	0xbc, 0xff, 0xf4, 0x6b, 0x6a, 0x6a, 0x77, 0x53, 0x53, 0xfb, 0x33, 0x35, 0xb5, 0xef, 0x33, 0xb3,
	0x70, 0x37, 0x33, 0x0b, 0xbf, 0x67, 0x66, 0xe1, 0xcb, 0xeb, 0xab, 0x41, 0x7a, 0xfd, 0xed, 0x92,
	0x67, 0xd8, 0xe6, 0x71, 0x7e, 0x35, 0x88, 0xe7, 0x5f, 0x3b, 0xbd, 0x1e, 0xc8, 0x7e, 0x38, 0xee,
	0xc9, 0xf4, 0xd6, 0xe6, 0x19, 0x4e, 0x6c, 0x35, 0xe6, 0x97, 0x1b, 0xf3, 0xd7, 0xf2, 0xf6, 0x6f,
	0x00, 0x00, 0x00, 0xff, 0xff, 0xd1, 0xaf, 0x10, 0x6f, 0x47, 0x03, 0x00, 0x00,
}

func (m *WalletEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WalletEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WalletEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= WALLET_EVENT_TYPE(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
