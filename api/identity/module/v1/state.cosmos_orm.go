// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package modulev1

import (
	context "context"
	ormlist "cosmossdk.io/orm/model/ormlist"
	ormtable "cosmossdk.io/orm/model/ormtable"
	ormerrors "cosmossdk.io/orm/types/ormerrors"
)

type AccountTable interface {
	Insert(ctx context.Context, account *Account) error
	InsertReturningSequence(ctx context.Context, account *Account) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, account *Account) error
	Save(ctx context.Context, account *Account) error
	Delete(ctx context.Context, account *Account) error
	Has(ctx context.Context, sequence uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, sequence uint64) (*Account, error)
	HasByAddress(ctx context.Context, address string) (found bool, err error)
	// GetByAddress returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByAddress(ctx context.Context, address string) (*Account, error)
	HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error)
	// GetByPublicKey returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByPublicKey(ctx context.Context, public_key []byte) (*Account, error)
	List(ctx context.Context, prefixKey AccountIndexKey, opts ...ormlist.Option) (AccountIterator, error)
	ListRange(ctx context.Context, from, to AccountIndexKey, opts ...ormlist.Option) (AccountIterator, error)
	DeleteBy(ctx context.Context, prefixKey AccountIndexKey) error
	DeleteRange(ctx context.Context, from, to AccountIndexKey) error

	doNotImplement()
}

type AccountIterator struct {
	ormtable.Iterator
}

func (i AccountIterator) Value() (*Account, error) {
	var account Account
	err := i.UnmarshalMessage(&account)
	return &account, err
}

type AccountIndexKey interface {
	id() uint32
	values() []interface{}
	accountIndexKey()
}

// primary key starting index..
type AccountPrimaryKey = AccountSequenceIndexKey

type AccountSequenceIndexKey struct {
	vs []interface{}
}

func (x AccountSequenceIndexKey) id() uint32            { return 0 }
func (x AccountSequenceIndexKey) values() []interface{} { return x.vs }
func (x AccountSequenceIndexKey) accountIndexKey()      {}

func (this AccountSequenceIndexKey) WithSequence(sequence uint64) AccountSequenceIndexKey {
	this.vs = []interface{}{sequence}
	return this
}

type AccountAddressIndexKey struct {
	vs []interface{}
}

func (x AccountAddressIndexKey) id() uint32            { return 1 }
func (x AccountAddressIndexKey) values() []interface{} { return x.vs }
func (x AccountAddressIndexKey) accountIndexKey()      {}

func (this AccountAddressIndexKey) WithAddress(address string) AccountAddressIndexKey {
	this.vs = []interface{}{address}
	return this
}

type AccountPublicKeyIndexKey struct {
	vs []interface{}
}

func (x AccountPublicKeyIndexKey) id() uint32            { return 2 }
func (x AccountPublicKeyIndexKey) values() []interface{} { return x.vs }
func (x AccountPublicKeyIndexKey) accountIndexKey()      {}

func (this AccountPublicKeyIndexKey) WithPublicKey(public_key []byte) AccountPublicKeyIndexKey {
	this.vs = []interface{}{public_key}
	return this
}

type accountTable struct {
	table ormtable.AutoIncrementTable
}

func (this accountTable) Insert(ctx context.Context, account *Account) error {
	return this.table.Insert(ctx, account)
}

func (this accountTable) Update(ctx context.Context, account *Account) error {
	return this.table.Update(ctx, account)
}

func (this accountTable) Save(ctx context.Context, account *Account) error {
	return this.table.Save(ctx, account)
}

func (this accountTable) Delete(ctx context.Context, account *Account) error {
	return this.table.Delete(ctx, account)
}

func (this accountTable) InsertReturningSequence(ctx context.Context, account *Account) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, account)
}

func (this accountTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this accountTable) Has(ctx context.Context, sequence uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, sequence)
}

func (this accountTable) Get(ctx context.Context, sequence uint64) (*Account, error) {
	var account Account
	found, err := this.table.PrimaryKey().Get(ctx, &account, sequence)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &account, nil
}

func (this accountTable) HasByAddress(ctx context.Context, address string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		address,
	)
}

func (this accountTable) GetByAddress(ctx context.Context, address string) (*Account, error) {
	var account Account
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &account,
		address,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &account, nil
}

func (this accountTable) HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		public_key,
	)
}

func (this accountTable) GetByPublicKey(ctx context.Context, public_key []byte) (*Account, error) {
	var account Account
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &account,
		public_key,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &account, nil
}

func (this accountTable) List(ctx context.Context, prefixKey AccountIndexKey, opts ...ormlist.Option) (AccountIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return AccountIterator{it}, err
}

func (this accountTable) ListRange(ctx context.Context, from, to AccountIndexKey, opts ...ormlist.Option) (AccountIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return AccountIterator{it}, err
}

func (this accountTable) DeleteBy(ctx context.Context, prefixKey AccountIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this accountTable) DeleteRange(ctx context.Context, from, to AccountIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this accountTable) doNotImplement() {}

var _ AccountTable = accountTable{}

func NewAccountTable(db ormtable.Schema) (AccountTable, error) {
	table := db.GetTable(&Account{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Account{}).ProtoReflect().Descriptor().FullName()))
	}
	return accountTable{table.(ormtable.AutoIncrementTable)}, nil
}

type BlockchainTable interface {
	Insert(ctx context.Context, blockchain *Blockchain) error
	InsertReturningIndex(ctx context.Context, blockchain *Blockchain) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, blockchain *Blockchain) error
	Save(ctx context.Context, blockchain *Blockchain) error
	Delete(ctx context.Context, blockchain *Blockchain) error
	Has(ctx context.Context, index uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, index uint64) (*Blockchain, error)
	HasByChainId(ctx context.Context, chain_id string) (found bool, err error)
	// GetByChainId returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByChainId(ctx context.Context, chain_id string) (*Blockchain, error)
	HasByName(ctx context.Context, name string) (found bool, err error)
	// GetByName returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByName(ctx context.Context, name string) (*Blockchain, error)
	List(ctx context.Context, prefixKey BlockchainIndexKey, opts ...ormlist.Option) (BlockchainIterator, error)
	ListRange(ctx context.Context, from, to BlockchainIndexKey, opts ...ormlist.Option) (BlockchainIterator, error)
	DeleteBy(ctx context.Context, prefixKey BlockchainIndexKey) error
	DeleteRange(ctx context.Context, from, to BlockchainIndexKey) error

	doNotImplement()
}

type BlockchainIterator struct {
	ormtable.Iterator
}

func (i BlockchainIterator) Value() (*Blockchain, error) {
	var blockchain Blockchain
	err := i.UnmarshalMessage(&blockchain)
	return &blockchain, err
}

type BlockchainIndexKey interface {
	id() uint32
	values() []interface{}
	blockchainIndexKey()
}

// primary key starting index..
type BlockchainPrimaryKey = BlockchainIndexIndexKey

type BlockchainIndexIndexKey struct {
	vs []interface{}
}

func (x BlockchainIndexIndexKey) id() uint32            { return 0 }
func (x BlockchainIndexIndexKey) values() []interface{} { return x.vs }
func (x BlockchainIndexIndexKey) blockchainIndexKey()   {}

func (this BlockchainIndexIndexKey) WithIndex(index uint64) BlockchainIndexIndexKey {
	this.vs = []interface{}{index}
	return this
}

type BlockchainChainIdIndexKey struct {
	vs []interface{}
}

func (x BlockchainChainIdIndexKey) id() uint32            { return 1 }
func (x BlockchainChainIdIndexKey) values() []interface{} { return x.vs }
func (x BlockchainChainIdIndexKey) blockchainIndexKey()   {}

func (this BlockchainChainIdIndexKey) WithChainId(chain_id string) BlockchainChainIdIndexKey {
	this.vs = []interface{}{chain_id}
	return this
}

type BlockchainNameIndexKey struct {
	vs []interface{}
}

func (x BlockchainNameIndexKey) id() uint32            { return 2 }
func (x BlockchainNameIndexKey) values() []interface{} { return x.vs }
func (x BlockchainNameIndexKey) blockchainIndexKey()   {}

func (this BlockchainNameIndexKey) WithName(name string) BlockchainNameIndexKey {
	this.vs = []interface{}{name}
	return this
}

type blockchainTable struct {
	table ormtable.AutoIncrementTable
}

func (this blockchainTable) Insert(ctx context.Context, blockchain *Blockchain) error {
	return this.table.Insert(ctx, blockchain)
}

func (this blockchainTable) Update(ctx context.Context, blockchain *Blockchain) error {
	return this.table.Update(ctx, blockchain)
}

func (this blockchainTable) Save(ctx context.Context, blockchain *Blockchain) error {
	return this.table.Save(ctx, blockchain)
}

func (this blockchainTable) Delete(ctx context.Context, blockchain *Blockchain) error {
	return this.table.Delete(ctx, blockchain)
}

func (this blockchainTable) InsertReturningIndex(ctx context.Context, blockchain *Blockchain) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, blockchain)
}

func (this blockchainTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this blockchainTable) Has(ctx context.Context, index uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, index)
}

func (this blockchainTable) Get(ctx context.Context, index uint64) (*Blockchain, error) {
	var blockchain Blockchain
	found, err := this.table.PrimaryKey().Get(ctx, &blockchain, index)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchain, nil
}

func (this blockchainTable) HasByChainId(ctx context.Context, chain_id string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		chain_id,
	)
}

func (this blockchainTable) GetByChainId(ctx context.Context, chain_id string) (*Blockchain, error) {
	var blockchain Blockchain
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &blockchain,
		chain_id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchain, nil
}

func (this blockchainTable) HasByName(ctx context.Context, name string) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		name,
	)
}

func (this blockchainTable) GetByName(ctx context.Context, name string) (*Blockchain, error) {
	var blockchain Blockchain
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &blockchain,
		name,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchain, nil
}

func (this blockchainTable) List(ctx context.Context, prefixKey BlockchainIndexKey, opts ...ormlist.Option) (BlockchainIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BlockchainIterator{it}, err
}

func (this blockchainTable) ListRange(ctx context.Context, from, to BlockchainIndexKey, opts ...ormlist.Option) (BlockchainIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BlockchainIterator{it}, err
}

func (this blockchainTable) DeleteBy(ctx context.Context, prefixKey BlockchainIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this blockchainTable) DeleteRange(ctx context.Context, from, to BlockchainIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this blockchainTable) doNotImplement() {}

var _ BlockchainTable = blockchainTable{}

func NewBlockchainTable(db ormtable.Schema) (BlockchainTable, error) {
	table := db.GetTable(&Blockchain{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Blockchain{}).ProtoReflect().Descriptor().FullName()))
	}
	return blockchainTable{table.(ormtable.AutoIncrementTable)}, nil
}

type IdentifierTable interface {
	Insert(ctx context.Context, identifier *Identifier) error
	InsertReturningIndex(ctx context.Context, identifier *Identifier) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, identifier *Identifier) error
	Save(ctx context.Context, identifier *Identifier) error
	Delete(ctx context.Context, identifier *Identifier) error
	Has(ctx context.Context, index uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, index uint64) (*Identifier, error)
	List(ctx context.Context, prefixKey IdentifierIndexKey, opts ...ormlist.Option) (IdentifierIterator, error)
	ListRange(ctx context.Context, from, to IdentifierIndexKey, opts ...ormlist.Option) (IdentifierIterator, error)
	DeleteBy(ctx context.Context, prefixKey IdentifierIndexKey) error
	DeleteRange(ctx context.Context, from, to IdentifierIndexKey) error

	doNotImplement()
}

type IdentifierIterator struct {
	ormtable.Iterator
}

func (i IdentifierIterator) Value() (*Identifier, error) {
	var identifier Identifier
	err := i.UnmarshalMessage(&identifier)
	return &identifier, err
}

type IdentifierIndexKey interface {
	id() uint32
	values() []interface{}
	identifierIndexKey()
}

// primary key starting index..
type IdentifierPrimaryKey = IdentifierIndexIndexKey

type IdentifierIndexIndexKey struct {
	vs []interface{}
}

func (x IdentifierIndexIndexKey) id() uint32            { return 0 }
func (x IdentifierIndexIndexKey) values() []interface{} { return x.vs }
func (x IdentifierIndexIndexKey) identifierIndexKey()   {}

func (this IdentifierIndexIndexKey) WithIndex(index uint64) IdentifierIndexIndexKey {
	this.vs = []interface{}{index}
	return this
}

type identifierTable struct {
	table ormtable.AutoIncrementTable
}

func (this identifierTable) Insert(ctx context.Context, identifier *Identifier) error {
	return this.table.Insert(ctx, identifier)
}

func (this identifierTable) Update(ctx context.Context, identifier *Identifier) error {
	return this.table.Update(ctx, identifier)
}

func (this identifierTable) Save(ctx context.Context, identifier *Identifier) error {
	return this.table.Save(ctx, identifier)
}

func (this identifierTable) Delete(ctx context.Context, identifier *Identifier) error {
	return this.table.Delete(ctx, identifier)
}

func (this identifierTable) InsertReturningIndex(ctx context.Context, identifier *Identifier) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, identifier)
}

func (this identifierTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this identifierTable) Has(ctx context.Context, index uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, index)
}

func (this identifierTable) Get(ctx context.Context, index uint64) (*Identifier, error) {
	var identifier Identifier
	found, err := this.table.PrimaryKey().Get(ctx, &identifier, index)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identifier, nil
}

func (this identifierTable) List(ctx context.Context, prefixKey IdentifierIndexKey, opts ...ormlist.Option) (IdentifierIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return IdentifierIterator{it}, err
}

func (this identifierTable) ListRange(ctx context.Context, from, to IdentifierIndexKey, opts ...ormlist.Option) (IdentifierIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return IdentifierIterator{it}, err
}

func (this identifierTable) DeleteBy(ctx context.Context, prefixKey IdentifierIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this identifierTable) DeleteRange(ctx context.Context, from, to IdentifierIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this identifierTable) doNotImplement() {}

var _ IdentifierTable = identifierTable{}

func NewIdentifierTable(db ormtable.Schema) (IdentifierTable, error) {
	table := db.GetTable(&Identifier{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&Identifier{}).ProtoReflect().Descriptor().FullName()))
	}
	return identifierTable{table.(ormtable.AutoIncrementTable)}, nil
}

type StateStore interface {
	AccountTable() AccountTable
	BlockchainTable() BlockchainTable
	IdentifierTable() IdentifierTable

	doNotImplement()
}

type stateStore struct {
	account    AccountTable
	blockchain BlockchainTable
	identifier IdentifierTable
}

func (x stateStore) AccountTable() AccountTable {
	return x.account
}

func (x stateStore) BlockchainTable() BlockchainTable {
	return x.blockchain
}

func (x stateStore) IdentifierTable() IdentifierTable {
	return x.identifier
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	accountTable, err := NewAccountTable(db)
	if err != nil {
		return nil, err
	}

	blockchainTable, err := NewBlockchainTable(db)
	if err != nil {
		return nil, err
	}

	identifierTable, err := NewIdentifierTable(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		accountTable,
		blockchainTable,
		identifierTable,
	}, nil
}
