// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocols/discover/v1/discover.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protocols_2fdiscover_2fv1_2fdiscover_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protocols_2fdiscover_2fv1_2fdiscover_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/core.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protocols_2fdiscover_2fv1_2fdiscover_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protocols_2fdiscover_2fv1_2fdiscover_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protocols_2fdiscover_2fv1_2fdiscover_2eproto;
namespace protocols {
namespace discover {
namespace v1 {
class LobbyMessage;
struct LobbyMessageDefaultTypeInternal;
extern LobbyMessageDefaultTypeInternal _LobbyMessage_default_instance_;
class VisibilityRequest;
struct VisibilityRequestDefaultTypeInternal;
extern VisibilityRequestDefaultTypeInternal _VisibilityRequest_default_instance_;
class VisibilityResponse;
struct VisibilityResponseDefaultTypeInternal;
extern VisibilityResponseDefaultTypeInternal _VisibilityResponse_default_instance_;
}  // namespace v1
}  // namespace discover
}  // namespace protocols
PROTOBUF_NAMESPACE_OPEN
template<> ::protocols::discover::v1::LobbyMessage* Arena::CreateMaybeMessage<::protocols::discover::v1::LobbyMessage>(Arena*);
template<> ::protocols::discover::v1::VisibilityRequest* Arena::CreateMaybeMessage<::protocols::discover::v1::VisibilityRequest>(Arena*);
template<> ::protocols::discover::v1::VisibilityResponse* Arena::CreateMaybeMessage<::protocols::discover::v1::VisibilityResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocols {
namespace discover {
namespace v1 {

enum VisibilityRequest_Visibility : int {
  VisibilityRequest_Visibility_VISIBILITY_UNSPECIFIED = 0,
  VisibilityRequest_Visibility_VISIBILITY_AVAILABLE = 1,
  VisibilityRequest_Visibility_VISIBILITY_HIDDEN = 2,
  VisibilityRequest_Visibility_VISIBILITY_FRIENDS = 3,
  VisibilityRequest_Visibility_VisibilityRequest_Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VisibilityRequest_Visibility_VisibilityRequest_Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VisibilityRequest_Visibility_IsValid(int value);
constexpr VisibilityRequest_Visibility VisibilityRequest_Visibility_Visibility_MIN = VisibilityRequest_Visibility_VISIBILITY_UNSPECIFIED;
constexpr VisibilityRequest_Visibility VisibilityRequest_Visibility_Visibility_MAX = VisibilityRequest_Visibility_VISIBILITY_FRIENDS;
constexpr int VisibilityRequest_Visibility_Visibility_ARRAYSIZE = VisibilityRequest_Visibility_Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisibilityRequest_Visibility_descriptor();
template<typename T>
inline const std::string& VisibilityRequest_Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisibilityRequest_Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisibilityRequest_Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisibilityRequest_Visibility_descriptor(), enum_t_value);
}
inline bool VisibilityRequest_Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VisibilityRequest_Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisibilityRequest_Visibility>(
    VisibilityRequest_Visibility_descriptor(), name, value);
}
enum VisibilityResponse_Visibility : int {
  VisibilityResponse_Visibility_VISIBILITY_UNSPECIFIED = 0,
  VisibilityResponse_Visibility_VISIBILITY_AVAILABLE = 1,
  VisibilityResponse_Visibility_VISIBILITY_HIDDEN = 2,
  VisibilityResponse_Visibility_VISIBILITY_FRIENDS = 3,
  VisibilityResponse_Visibility_VisibilityResponse_Visibility_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  VisibilityResponse_Visibility_VisibilityResponse_Visibility_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VisibilityResponse_Visibility_IsValid(int value);
constexpr VisibilityResponse_Visibility VisibilityResponse_Visibility_Visibility_MIN = VisibilityResponse_Visibility_VISIBILITY_UNSPECIFIED;
constexpr VisibilityResponse_Visibility VisibilityResponse_Visibility_Visibility_MAX = VisibilityResponse_Visibility_VISIBILITY_FRIENDS;
constexpr int VisibilityResponse_Visibility_Visibility_ARRAYSIZE = VisibilityResponse_Visibility_Visibility_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VisibilityResponse_Visibility_descriptor();
template<typename T>
inline const std::string& VisibilityResponse_Visibility_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VisibilityResponse_Visibility>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VisibilityResponse_Visibility_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VisibilityResponse_Visibility_descriptor(), enum_t_value);
}
inline bool VisibilityResponse_Visibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VisibilityResponse_Visibility* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VisibilityResponse_Visibility>(
    VisibilityResponse_Visibility_descriptor(), name, value);
}
// ===================================================================

class LobbyMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocols.discover.v1.LobbyMessage) */ {
 public:
  inline LobbyMessage() : LobbyMessage(nullptr) {}
  ~LobbyMessage() override;
  explicit constexpr LobbyMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LobbyMessage(const LobbyMessage& from);
  LobbyMessage(LobbyMessage&& from) noexcept
    : LobbyMessage() {
    *this = ::std::move(from);
  }

  inline LobbyMessage& operator=(const LobbyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LobbyMessage& operator=(LobbyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LobbyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LobbyMessage* internal_default_instance() {
    return reinterpret_cast<const LobbyMessage*>(
               &_LobbyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LobbyMessage& a, LobbyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LobbyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LobbyMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LobbyMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LobbyMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LobbyMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LobbyMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LobbyMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocols.discover.v1.LobbyMessage";
  }
  protected:
  explicit LobbyMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kPeerFieldNumber = 1,
    kMetadataFieldNumber = 3,
  };
  // optional string message = 2 [json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .common.v1.Peer peer = 1 [json_name = "peer"];
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::common::v1::Peer& peer() const;
  PROTOBUF_NODISCARD ::common::v1::Peer* release_peer();
  ::common::v1::Peer* mutable_peer();
  void set_allocated_peer(::common::v1::Peer* peer);
  private:
  const ::common::v1::Peer& _internal_peer() const;
  ::common::v1::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::common::v1::Peer* peer);
  ::common::v1::Peer* unsafe_arena_release_peer();

  // .common.v1.Metadata metadata = 3 [json_name = "metadata"];
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::common::v1::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::common::v1::Metadata* release_metadata();
  ::common::v1::Metadata* mutable_metadata();
  void set_allocated_metadata(::common::v1::Metadata* metadata);
  private:
  const ::common::v1::Metadata& _internal_metadata() const;
  ::common::v1::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::common::v1::Metadata* metadata);
  ::common::v1::Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:protocols.discover.v1.LobbyMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::common::v1::Peer* peer_;
  ::common::v1::Metadata* metadata_;
  friend struct ::TableStruct_protocols_2fdiscover_2fv1_2fdiscover_2eproto;
};
// -------------------------------------------------------------------

class VisibilityRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocols.discover.v1.VisibilityRequest) */ {
 public:
  inline VisibilityRequest() : VisibilityRequest(nullptr) {}
  ~VisibilityRequest() override;
  explicit constexpr VisibilityRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisibilityRequest(const VisibilityRequest& from);
  VisibilityRequest(VisibilityRequest&& from) noexcept
    : VisibilityRequest() {
    *this = ::std::move(from);
  }

  inline VisibilityRequest& operator=(const VisibilityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisibilityRequest& operator=(VisibilityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisibilityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisibilityRequest* internal_default_instance() {
    return reinterpret_cast<const VisibilityRequest*>(
               &_VisibilityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(VisibilityRequest& a, VisibilityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VisibilityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisibilityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisibilityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisibilityRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisibilityRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VisibilityRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisibilityRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocols.discover.v1.VisibilityRequest";
  }
  protected:
  explicit VisibilityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VisibilityRequest_Visibility Visibility;
  static constexpr Visibility VISIBILITY_UNSPECIFIED =
    VisibilityRequest_Visibility_VISIBILITY_UNSPECIFIED;
  static constexpr Visibility VISIBILITY_AVAILABLE =
    VisibilityRequest_Visibility_VISIBILITY_AVAILABLE;
  static constexpr Visibility VISIBILITY_HIDDEN =
    VisibilityRequest_Visibility_VISIBILITY_HIDDEN;
  static constexpr Visibility VISIBILITY_FRIENDS =
    VisibilityRequest_Visibility_VISIBILITY_FRIENDS;
  static inline bool Visibility_IsValid(int value) {
    return VisibilityRequest_Visibility_IsValid(value);
  }
  static constexpr Visibility Visibility_MIN =
    VisibilityRequest_Visibility_Visibility_MIN;
  static constexpr Visibility Visibility_MAX =
    VisibilityRequest_Visibility_Visibility_MAX;
  static constexpr int Visibility_ARRAYSIZE =
    VisibilityRequest_Visibility_Visibility_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Visibility_descriptor() {
    return VisibilityRequest_Visibility_descriptor();
  }
  template<typename T>
  static inline const std::string& Visibility_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Visibility>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Visibility_Name.");
    return VisibilityRequest_Visibility_Name(enum_t_value);
  }
  static inline bool Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Visibility* value) {
    return VisibilityRequest_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPublicKeyFieldNumber = 2,
    kVisibilityFieldNumber = 3,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // bytes public_key = 2 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // .protocols.discover.v1.VisibilityRequest.Visibility visibility = 3 [json_name = "visibility"];
  void clear_visibility();
  ::protocols::discover::v1::VisibilityRequest_Visibility visibility() const;
  void set_visibility(::protocols::discover::v1::VisibilityRequest_Visibility value);
  private:
  ::protocols::discover::v1::VisibilityRequest_Visibility _internal_visibility() const;
  void _internal_set_visibility(::protocols::discover::v1::VisibilityRequest_Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:protocols.discover.v1.VisibilityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocols_2fdiscover_2fv1_2fdiscover_2eproto;
};
// -------------------------------------------------------------------

class VisibilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocols.discover.v1.VisibilityResponse) */ {
 public:
  inline VisibilityResponse() : VisibilityResponse(nullptr) {}
  ~VisibilityResponse() override;
  explicit constexpr VisibilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VisibilityResponse(const VisibilityResponse& from);
  VisibilityResponse(VisibilityResponse&& from) noexcept
    : VisibilityResponse() {
    *this = ::std::move(from);
  }

  inline VisibilityResponse& operator=(const VisibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VisibilityResponse& operator=(VisibilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VisibilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VisibilityResponse* internal_default_instance() {
    return reinterpret_cast<const VisibilityResponse*>(
               &_VisibilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(VisibilityResponse& a, VisibilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VisibilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VisibilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VisibilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VisibilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VisibilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VisibilityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VisibilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocols.discover.v1.VisibilityResponse";
  }
  protected:
  explicit VisibilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VisibilityResponse_Visibility Visibility;
  static constexpr Visibility VISIBILITY_UNSPECIFIED =
    VisibilityResponse_Visibility_VISIBILITY_UNSPECIFIED;
  static constexpr Visibility VISIBILITY_AVAILABLE =
    VisibilityResponse_Visibility_VISIBILITY_AVAILABLE;
  static constexpr Visibility VISIBILITY_HIDDEN =
    VisibilityResponse_Visibility_VISIBILITY_HIDDEN;
  static constexpr Visibility VISIBILITY_FRIENDS =
    VisibilityResponse_Visibility_VISIBILITY_FRIENDS;
  static inline bool Visibility_IsValid(int value) {
    return VisibilityResponse_Visibility_IsValid(value);
  }
  static constexpr Visibility Visibility_MIN =
    VisibilityResponse_Visibility_Visibility_MIN;
  static constexpr Visibility Visibility_MAX =
    VisibilityResponse_Visibility_Visibility_MAX;
  static constexpr int Visibility_ARRAYSIZE =
    VisibilityResponse_Visibility_Visibility_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Visibility_descriptor() {
    return VisibilityResponse_Visibility_descriptor();
  }
  template<typename T>
  static inline const std::string& Visibility_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Visibility>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Visibility_Name.");
    return VisibilityResponse_Visibility_Name(enum_t_value);
  }
  static inline bool Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Visibility* value) {
    return VisibilityResponse_Visibility_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
    kVisibilityFieldNumber = 3,
  };
  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // .protocols.discover.v1.VisibilityResponse.Visibility visibility = 3 [json_name = "visibility"];
  void clear_visibility();
  ::protocols::discover::v1::VisibilityResponse_Visibility visibility() const;
  void set_visibility(::protocols::discover::v1::VisibilityResponse_Visibility value);
  private:
  ::protocols::discover::v1::VisibilityResponse_Visibility _internal_visibility() const;
  void _internal_set_visibility(::protocols::discover::v1::VisibilityResponse_Visibility value);
  public:

  // @@protoc_insertion_point(class_scope:protocols.discover.v1.VisibilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  int visibility_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protocols_2fdiscover_2fv1_2fdiscover_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LobbyMessage

// .common.v1.Peer peer = 1 [json_name = "peer"];
inline bool LobbyMessage::_internal_has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline bool LobbyMessage::has_peer() const {
  return _internal_has_peer();
}
inline const ::common::v1::Peer& LobbyMessage::_internal_peer() const {
  const ::common::v1::Peer* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Peer&>(
      ::common::v1::_Peer_default_instance_);
}
inline const ::common::v1::Peer& LobbyMessage::peer() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.LobbyMessage.peer)
  return _internal_peer();
}
inline void LobbyMessage::unsafe_arena_set_allocated_peer(
    ::common::v1::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocols.discover.v1.LobbyMessage.peer)
}
inline ::common::v1::Peer* LobbyMessage::release_peer() {
  
  ::common::v1::Peer* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Peer* LobbyMessage::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.LobbyMessage.peer)
  
  ::common::v1::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::common::v1::Peer* LobbyMessage::_internal_mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Peer>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::common::v1::Peer* LobbyMessage::mutable_peer() {
  ::common::v1::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.LobbyMessage.peer)
  return _msg;
}
inline void LobbyMessage::set_allocated_peer(::common::v1::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.LobbyMessage.peer)
}

// optional string message = 2 [json_name = "message"];
inline bool LobbyMessage::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LobbyMessage::has_message() const {
  return _internal_has_message();
}
inline void LobbyMessage::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LobbyMessage::message() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.LobbyMessage.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LobbyMessage::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocols.discover.v1.LobbyMessage.message)
}
inline std::string* LobbyMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.LobbyMessage.message)
  return _s;
}
inline const std::string& LobbyMessage::_internal_message() const {
  return message_.Get();
}
inline void LobbyMessage::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LobbyMessage::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LobbyMessage::release_message() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.LobbyMessage.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void LobbyMessage::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.LobbyMessage.message)
}

// .common.v1.Metadata metadata = 3 [json_name = "metadata"];
inline bool LobbyMessage::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool LobbyMessage::has_metadata() const {
  return _internal_has_metadata();
}
inline const ::common::v1::Metadata& LobbyMessage::_internal_metadata() const {
  const ::common::v1::Metadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Metadata&>(
      ::common::v1::_Metadata_default_instance_);
}
inline const ::common::v1::Metadata& LobbyMessage::metadata() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.LobbyMessage.metadata)
  return _internal_metadata();
}
inline void LobbyMessage::unsafe_arena_set_allocated_metadata(
    ::common::v1::Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocols.discover.v1.LobbyMessage.metadata)
}
inline ::common::v1::Metadata* LobbyMessage::release_metadata() {
  
  ::common::v1::Metadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Metadata* LobbyMessage::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.LobbyMessage.metadata)
  
  ::common::v1::Metadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::common::v1::Metadata* LobbyMessage::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Metadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::common::v1::Metadata* LobbyMessage::mutable_metadata() {
  ::common::v1::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.LobbyMessage.metadata)
  return _msg;
}
inline void LobbyMessage::set_allocated_metadata(::common::v1::Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata));
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.LobbyMessage.metadata)
}

// -------------------------------------------------------------------

// VisibilityRequest

// string s_name = 1 [json_name = "sName"];
inline void VisibilityRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& VisibilityRequest::s_name() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisibilityRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityRequest.s_name)
}
inline std::string* VisibilityRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.VisibilityRequest.s_name)
  return _s;
}
inline const std::string& VisibilityRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void VisibilityRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VisibilityRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VisibilityRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.VisibilityRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VisibilityRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.VisibilityRequest.s_name)
}

// bytes public_key = 2 [json_name = "publicKey"];
inline void VisibilityRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& VisibilityRequest::public_key() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisibilityRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityRequest.public_key)
}
inline std::string* VisibilityRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.VisibilityRequest.public_key)
  return _s;
}
inline const std::string& VisibilityRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void VisibilityRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VisibilityRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VisibilityRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.VisibilityRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VisibilityRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.VisibilityRequest.public_key)
}

// .protocols.discover.v1.VisibilityRequest.Visibility visibility = 3 [json_name = "visibility"];
inline void VisibilityRequest::clear_visibility() {
  visibility_ = 0;
}
inline ::protocols::discover::v1::VisibilityRequest_Visibility VisibilityRequest::_internal_visibility() const {
  return static_cast< ::protocols::discover::v1::VisibilityRequest_Visibility >(visibility_);
}
inline ::protocols::discover::v1::VisibilityRequest_Visibility VisibilityRequest::visibility() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityRequest.visibility)
  return _internal_visibility();
}
inline void VisibilityRequest::_internal_set_visibility(::protocols::discover::v1::VisibilityRequest_Visibility value) {
  
  visibility_ = value;
}
inline void VisibilityRequest::set_visibility(::protocols::discover::v1::VisibilityRequest_Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityRequest.visibility)
}

// -------------------------------------------------------------------

// VisibilityResponse

// bool success = 1 [json_name = "success"];
inline void VisibilityResponse::clear_success() {
  success_ = false;
}
inline bool VisibilityResponse::_internal_success() const {
  return success_;
}
inline bool VisibilityResponse::success() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityResponse.success)
  return _internal_success();
}
inline void VisibilityResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void VisibilityResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityResponse.success)
}

// string error = 2 [json_name = "error"];
inline void VisibilityResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& VisibilityResponse::error() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VisibilityResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityResponse.error)
}
inline std::string* VisibilityResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:protocols.discover.v1.VisibilityResponse.error)
  return _s;
}
inline const std::string& VisibilityResponse::_internal_error() const {
  return error_.Get();
}
inline void VisibilityResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VisibilityResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VisibilityResponse::release_error() {
  // @@protoc_insertion_point(field_release:protocols.discover.v1.VisibilityResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VisibilityResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protocols.discover.v1.VisibilityResponse.error)
}

// .protocols.discover.v1.VisibilityResponse.Visibility visibility = 3 [json_name = "visibility"];
inline void VisibilityResponse::clear_visibility() {
  visibility_ = 0;
}
inline ::protocols::discover::v1::VisibilityResponse_Visibility VisibilityResponse::_internal_visibility() const {
  return static_cast< ::protocols::discover::v1::VisibilityResponse_Visibility >(visibility_);
}
inline ::protocols::discover::v1::VisibilityResponse_Visibility VisibilityResponse::visibility() const {
  // @@protoc_insertion_point(field_get:protocols.discover.v1.VisibilityResponse.visibility)
  return _internal_visibility();
}
inline void VisibilityResponse::_internal_set_visibility(::protocols::discover::v1::VisibilityResponse_Visibility value) {
  
  visibility_ = value;
}
inline void VisibilityResponse::set_visibility(::protocols::discover::v1::VisibilityResponse_Visibility value) {
  _internal_set_visibility(value);
  // @@protoc_insertion_point(field_set:protocols.discover.v1.VisibilityResponse.visibility)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace discover
}  // namespace protocols

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocols::discover::v1::VisibilityRequest_Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocols::discover::v1::VisibilityRequest_Visibility>() {
  return ::protocols::discover::v1::VisibilityRequest_Visibility_descriptor();
}
template <> struct is_proto_enum< ::protocols::discover::v1::VisibilityResponse_Visibility> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocols::discover::v1::VisibilityResponse_Visibility>() {
  return ::protocols::discover::v1::VisibilityResponse_Visibility_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protocols_2fdiscover_2fv1_2fdiscover_2eproto
