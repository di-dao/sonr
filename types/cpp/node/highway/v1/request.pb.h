// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node/highway/v1/request.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2frequest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2frequest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/core.pb.h"
#include "common/v1/data.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_2fhighway_2fv1_2frequest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_2fhighway_2fv1_2frequest_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_node_2fhighway_2fv1_2frequest_2eproto;
namespace node {
namespace highway {
namespace v1 {
class CacheRecordRequest;
struct CacheRecordRequestDefaultTypeInternal;
extern CacheRecordRequestDefaultTypeInternal _CacheRecordRequest_default_instance_;
class CreateChannelRequest;
struct CreateChannelRequestDefaultTypeInternal;
extern CreateChannelRequestDefaultTypeInternal _CreateChannelRequest_default_instance_;
class DecideExchangeRequest;
struct DecideExchangeRequestDefaultTypeInternal;
extern DecideExchangeRequestDefaultTypeInternal _DecideExchangeRequest_default_instance_;
class GetRecordRequest;
struct GetRecordRequestDefaultTypeInternal;
extern GetRecordRequestDefaultTypeInternal _GetRecordRequest_default_instance_;
class ListPeersRequest;
struct ListPeersRequestDefaultTypeInternal;
extern ListPeersRequestDefaultTypeInternal _ListPeersRequest_default_instance_;
class RegisterNameRequest;
struct RegisterNameRequestDefaultTypeInternal;
extern RegisterNameRequestDefaultTypeInternal _RegisterNameRequest_default_instance_;
class SendExchangeRequest;
struct SendExchangeRequestDefaultTypeInternal;
extern SendExchangeRequestDefaultTypeInternal _SendExchangeRequest_default_instance_;
class StoreRecordRequest;
struct StoreRecordRequestDefaultTypeInternal;
extern StoreRecordRequestDefaultTypeInternal _StoreRecordRequest_default_instance_;
class SubscribeChannelRequest;
struct SubscribeChannelRequestDefaultTypeInternal;
extern SubscribeChannelRequestDefaultTypeInternal _SubscribeChannelRequest_default_instance_;
class UnsubscribeChannelRequest;
struct UnsubscribeChannelRequestDefaultTypeInternal;
extern UnsubscribeChannelRequestDefaultTypeInternal _UnsubscribeChannelRequest_default_instance_;
class UpdateChannelRequest;
struct UpdateChannelRequestDefaultTypeInternal;
extern UpdateChannelRequestDefaultTypeInternal _UpdateChannelRequest_default_instance_;
class UpdateChannelRequest_MetadataEntry_DoNotUse;
struct UpdateChannelRequest_MetadataEntry_DoNotUseDefaultTypeInternal;
extern UpdateChannelRequest_MetadataEntry_DoNotUseDefaultTypeInternal _UpdateChannelRequest_MetadataEntry_DoNotUse_default_instance_;
class VerifyNameRequest;
struct VerifyNameRequestDefaultTypeInternal;
extern VerifyNameRequestDefaultTypeInternal _VerifyNameRequest_default_instance_;
}  // namespace v1
}  // namespace highway
}  // namespace node
PROTOBUF_NAMESPACE_OPEN
template<> ::node::highway::v1::CacheRecordRequest* Arena::CreateMaybeMessage<::node::highway::v1::CacheRecordRequest>(Arena*);
template<> ::node::highway::v1::CreateChannelRequest* Arena::CreateMaybeMessage<::node::highway::v1::CreateChannelRequest>(Arena*);
template<> ::node::highway::v1::DecideExchangeRequest* Arena::CreateMaybeMessage<::node::highway::v1::DecideExchangeRequest>(Arena*);
template<> ::node::highway::v1::GetRecordRequest* Arena::CreateMaybeMessage<::node::highway::v1::GetRecordRequest>(Arena*);
template<> ::node::highway::v1::ListPeersRequest* Arena::CreateMaybeMessage<::node::highway::v1::ListPeersRequest>(Arena*);
template<> ::node::highway::v1::RegisterNameRequest* Arena::CreateMaybeMessage<::node::highway::v1::RegisterNameRequest>(Arena*);
template<> ::node::highway::v1::SendExchangeRequest* Arena::CreateMaybeMessage<::node::highway::v1::SendExchangeRequest>(Arena*);
template<> ::node::highway::v1::StoreRecordRequest* Arena::CreateMaybeMessage<::node::highway::v1::StoreRecordRequest>(Arena*);
template<> ::node::highway::v1::SubscribeChannelRequest* Arena::CreateMaybeMessage<::node::highway::v1::SubscribeChannelRequest>(Arena*);
template<> ::node::highway::v1::UnsubscribeChannelRequest* Arena::CreateMaybeMessage<::node::highway::v1::UnsubscribeChannelRequest>(Arena*);
template<> ::node::highway::v1::UpdateChannelRequest* Arena::CreateMaybeMessage<::node::highway::v1::UpdateChannelRequest>(Arena*);
template<> ::node::highway::v1::UpdateChannelRequest_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::UpdateChannelRequest_MetadataEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::VerifyNameRequest* Arena::CreateMaybeMessage<::node::highway::v1::VerifyNameRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace node {
namespace highway {
namespace v1 {

enum DecideExchangeRequest_Method : int {
  DecideExchangeRequest_Method_METHOD_UNSPECIFIED = 0,
  DecideExchangeRequest_Method_METHOD_ADD = 1,
  DecideExchangeRequest_Method_METHOD_REMOVE = 2,
  DecideExchangeRequest_Method_DecideExchangeRequest_Method_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DecideExchangeRequest_Method_DecideExchangeRequest_Method_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DecideExchangeRequest_Method_IsValid(int value);
constexpr DecideExchangeRequest_Method DecideExchangeRequest_Method_Method_MIN = DecideExchangeRequest_Method_METHOD_UNSPECIFIED;
constexpr DecideExchangeRequest_Method DecideExchangeRequest_Method_Method_MAX = DecideExchangeRequest_Method_METHOD_REMOVE;
constexpr int DecideExchangeRequest_Method_Method_ARRAYSIZE = DecideExchangeRequest_Method_Method_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DecideExchangeRequest_Method_descriptor();
template<typename T>
inline const std::string& DecideExchangeRequest_Method_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DecideExchangeRequest_Method>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DecideExchangeRequest_Method_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DecideExchangeRequest_Method_descriptor(), enum_t_value);
}
inline bool DecideExchangeRequest_Method_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DecideExchangeRequest_Method* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DecideExchangeRequest_Method>(
    DecideExchangeRequest_Method_descriptor(), name, value);
}
// ===================================================================

class CreateChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.CreateChannelRequest) */ {
 public:
  inline CreateChannelRequest() : CreateChannelRequest(nullptr) {}
  ~CreateChannelRequest() override;
  explicit constexpr CreateChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChannelRequest(const CreateChannelRequest& from);
  CreateChannelRequest(CreateChannelRequest&& from) noexcept
    : CreateChannelRequest() {
    *this = ::std::move(from);
  }

  inline CreateChannelRequest& operator=(const CreateChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChannelRequest& operator=(CreateChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChannelRequest* internal_default_instance() {
    return reinterpret_cast<const CreateChannelRequest*>(
               &_CreateChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateChannelRequest& a, CreateChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.CreateChannelRequest";
  }
  protected:
  explicit CreateChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOwnersFieldNumber = 3,
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  // repeated string owners = 3 [json_name = "owners"];
  int owners_size() const;
  private:
  int _internal_owners_size() const;
  public:
  void clear_owners();
  const std::string& owners(int index) const;
  std::string* mutable_owners(int index);
  void set_owners(int index, const std::string& value);
  void set_owners(int index, std::string&& value);
  void set_owners(int index, const char* value);
  void set_owners(int index, const char* value, size_t size);
  std::string* add_owners();
  void add_owners(const std::string& value);
  void add_owners(std::string&& value);
  void add_owners(const char* value);
  void add_owners(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& owners() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_owners();
  private:
  const std::string& _internal_owners(int index) const;
  std::string* _internal_add_owners();
  public:

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 2 [json_name = "description"];
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.CreateChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> owners_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class SubscribeChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.SubscribeChannelRequest) */ {
 public:
  inline SubscribeChannelRequest() : SubscribeChannelRequest(nullptr) {}
  ~SubscribeChannelRequest() override;
  explicit constexpr SubscribeChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeChannelRequest(const SubscribeChannelRequest& from);
  SubscribeChannelRequest(SubscribeChannelRequest&& from) noexcept
    : SubscribeChannelRequest() {
    *this = ::std::move(from);
  }

  inline SubscribeChannelRequest& operator=(const SubscribeChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeChannelRequest& operator=(SubscribeChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeChannelRequest* internal_default_instance() {
    return reinterpret_cast<const SubscribeChannelRequest*>(
               &_SubscribeChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubscribeChannelRequest& a, SubscribeChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.SubscribeChannelRequest";
  }
  protected:
  explicit SubscribeChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDidFieldNumber = 1,
  };
  // string did = 1 [json_name = "did"];
  void clear_did();
  const std::string& did() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did();
  PROTOBUF_NODISCARD std::string* release_did();
  void set_allocated_did(std::string* did);
  private:
  const std::string& _internal_did() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did(const std::string& value);
  std::string* _internal_mutable_did();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.SubscribeChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.UnsubscribeChannelRequest) */ {
 public:
  inline UnsubscribeChannelRequest() : UnsubscribeChannelRequest(nullptr) {}
  ~UnsubscribeChannelRequest() override;
  explicit constexpr UnsubscribeChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeChannelRequest(const UnsubscribeChannelRequest& from);
  UnsubscribeChannelRequest(UnsubscribeChannelRequest&& from) noexcept
    : UnsubscribeChannelRequest() {
    *this = ::std::move(from);
  }

  inline UnsubscribeChannelRequest& operator=(const UnsubscribeChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeChannelRequest& operator=(UnsubscribeChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeChannelRequest* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeChannelRequest*>(
               &_UnsubscribeChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnsubscribeChannelRequest& a, UnsubscribeChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsubscribeChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.UnsubscribeChannelRequest";
  }
  protected:
  explicit UnsubscribeChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDidFieldNumber = 1,
  };
  // string did = 1 [json_name = "did"];
  void clear_did();
  const std::string& did() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did();
  PROTOBUF_NODISCARD std::string* release_did();
  void set_allocated_did(std::string* did);
  private:
  const std::string& _internal_did() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did(const std::string& value);
  std::string* _internal_mutable_did();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.UnsubscribeChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class UpdateChannelRequest_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateChannelRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<UpdateChannelRequest_MetadataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  UpdateChannelRequest_MetadataEntry_DoNotUse();
  explicit constexpr UpdateChannelRequest_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit UpdateChannelRequest_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const UpdateChannelRequest_MetadataEntry_DoNotUse& other);
  static const UpdateChannelRequest_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const UpdateChannelRequest_MetadataEntry_DoNotUse*>(&_UpdateChannelRequest_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.UpdateChannelRequest.MetadataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.UpdateChannelRequest.MetadataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class UpdateChannelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.UpdateChannelRequest) */ {
 public:
  inline UpdateChannelRequest() : UpdateChannelRequest(nullptr) {}
  ~UpdateChannelRequest() override;
  explicit constexpr UpdateChannelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChannelRequest(const UpdateChannelRequest& from);
  UpdateChannelRequest(UpdateChannelRequest&& from) noexcept
    : UpdateChannelRequest() {
    *this = ::std::move(from);
  }

  inline UpdateChannelRequest& operator=(const UpdateChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChannelRequest& operator=(UpdateChannelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChannelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateChannelRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateChannelRequest*>(
               &_UpdateChannelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UpdateChannelRequest& a, UpdateChannelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChannelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChannelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChannelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChannelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChannelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateChannelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChannelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.UpdateChannelRequest";
  }
  protected:
  explicit UpdateChannelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 2,
    kDidFieldNumber = 1,
  };
  // map<string, string> metadata = 2 [json_name = "metadata"];
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_metadata();

  // string did = 1 [json_name = "did"];
  void clear_did();
  const std::string& did() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_did(ArgT0&& arg0, ArgT... args);
  std::string* mutable_did();
  PROTOBUF_NODISCARD std::string* release_did();
  void set_allocated_did(std::string* did);
  private:
  const std::string& _internal_did() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_did(const std::string& value);
  std::string* _internal_mutable_did();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.UpdateChannelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      UpdateChannelRequest_MetadataEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr did_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class ListPeersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.ListPeersRequest) */ {
 public:
  inline ListPeersRequest() : ListPeersRequest(nullptr) {}
  ~ListPeersRequest() override;
  explicit constexpr ListPeersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPeersRequest(const ListPeersRequest& from);
  ListPeersRequest(ListPeersRequest&& from) noexcept
    : ListPeersRequest() {
    *this = ::std::move(from);
  }

  inline ListPeersRequest& operator=(const ListPeersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPeersRequest& operator=(ListPeersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPeersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPeersRequest* internal_default_instance() {
    return reinterpret_cast<const ListPeersRequest*>(
               &_ListPeersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListPeersRequest& a, ListPeersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPeersRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPeersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPeersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPeersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPeersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPeersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPeersRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.ListPeersRequest";
  }
  protected:
  explicit ListPeersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kMnemonicFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string mnemonic = 2 [json_name = "mnemonic"];
  void clear_mnemonic();
  const std::string& mnemonic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mnemonic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mnemonic();
  PROTOBUF_NODISCARD std::string* release_mnemonic();
  void set_allocated_mnemonic(std::string* mnemonic);
  private:
  const std::string& _internal_mnemonic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mnemonic(const std::string& value);
  std::string* _internal_mutable_mnemonic();
  public:

  // string device_id = 3 [json_name = "deviceId"];
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.ListPeersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mnemonic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class DecideExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.DecideExchangeRequest) */ {
 public:
  inline DecideExchangeRequest() : DecideExchangeRequest(nullptr) {}
  ~DecideExchangeRequest() override;
  explicit constexpr DecideExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecideExchangeRequest(const DecideExchangeRequest& from);
  DecideExchangeRequest(DecideExchangeRequest&& from) noexcept
    : DecideExchangeRequest() {
    *this = ::std::move(from);
  }

  inline DecideExchangeRequest& operator=(const DecideExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecideExchangeRequest& operator=(DecideExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecideExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecideExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const DecideExchangeRequest*>(
               &_DecideExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DecideExchangeRequest& a, DecideExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DecideExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecideExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecideExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecideExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecideExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecideExchangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecideExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.DecideExchangeRequest";
  }
  protected:
  explicit DecideExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DecideExchangeRequest_Method Method;
  static constexpr Method METHOD_UNSPECIFIED =
    DecideExchangeRequest_Method_METHOD_UNSPECIFIED;
  static constexpr Method METHOD_ADD =
    DecideExchangeRequest_Method_METHOD_ADD;
  static constexpr Method METHOD_REMOVE =
    DecideExchangeRequest_Method_METHOD_REMOVE;
  static inline bool Method_IsValid(int value) {
    return DecideExchangeRequest_Method_IsValid(value);
  }
  static constexpr Method Method_MIN =
    DecideExchangeRequest_Method_Method_MIN;
  static constexpr Method Method_MAX =
    DecideExchangeRequest_Method_Method_MAX;
  static constexpr int Method_ARRAYSIZE =
    DecideExchangeRequest_Method_Method_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Method_descriptor() {
    return DecideExchangeRequest_Method_descriptor();
  }
  template<typename T>
  static inline const std::string& Method_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Method>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Method_Name.");
    return DecideExchangeRequest_Method_Name(enum_t_value);
  }
  static inline bool Method_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Method* value) {
    return DecideExchangeRequest_Method_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kMnemonicFieldNumber = 2,
    kDeviceIdFieldNumber = 3,
    kMethodFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string mnemonic = 2 [json_name = "mnemonic"];
  void clear_mnemonic();
  const std::string& mnemonic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mnemonic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mnemonic();
  PROTOBUF_NODISCARD std::string* release_mnemonic();
  void set_allocated_mnemonic(std::string* mnemonic);
  private:
  const std::string& _internal_mnemonic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mnemonic(const std::string& value);
  std::string* _internal_mutable_mnemonic();
  public:

  // string device_id = 3 [json_name = "deviceId"];
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // .node.highway.v1.DecideExchangeRequest.Method method = 4 [json_name = "method"];
  void clear_method();
  ::node::highway::v1::DecideExchangeRequest_Method method() const;
  void set_method(::node::highway::v1::DecideExchangeRequest_Method value);
  private:
  ::node::highway::v1::DecideExchangeRequest_Method _internal_method() const;
  void _internal_set_method(::node::highway::v1::DecideExchangeRequest_Method value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.DecideExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mnemonic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  int method_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class SendExchangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.SendExchangeRequest) */ {
 public:
  inline SendExchangeRequest() : SendExchangeRequest(nullptr) {}
  ~SendExchangeRequest() override;
  explicit constexpr SendExchangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendExchangeRequest(const SendExchangeRequest& from);
  SendExchangeRequest(SendExchangeRequest&& from) noexcept
    : SendExchangeRequest() {
    *this = ::std::move(from);
  }

  inline SendExchangeRequest& operator=(const SendExchangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendExchangeRequest& operator=(SendExchangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendExchangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendExchangeRequest* internal_default_instance() {
    return reinterpret_cast<const SendExchangeRequest*>(
               &_SendExchangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SendExchangeRequest& a, SendExchangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendExchangeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendExchangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendExchangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendExchangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendExchangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendExchangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendExchangeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.SendExchangeRequest";
  }
  protected:
  explicit SendExchangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 3,
    kPeerFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // repeated .common.v1.SupplyItem items = 3 [json_name = "items"];
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::common::v1::SupplyItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::SupplyItem >*
      mutable_items();
  private:
  const ::common::v1::SupplyItem& _internal_items(int index) const;
  ::common::v1::SupplyItem* _internal_add_items();
  public:
  const ::common::v1::SupplyItem& items(int index) const;
  ::common::v1::SupplyItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::SupplyItem >&
      items() const;

  // .common.v1.Peer peer = 1 [json_name = "peer"];
  bool has_peer() const;
  private:
  bool _internal_has_peer() const;
  public:
  void clear_peer();
  const ::common::v1::Peer& peer() const;
  PROTOBUF_NODISCARD ::common::v1::Peer* release_peer();
  ::common::v1::Peer* mutable_peer();
  void set_allocated_peer(::common::v1::Peer* peer);
  private:
  const ::common::v1::Peer& _internal_peer() const;
  ::common::v1::Peer* _internal_mutable_peer();
  public:
  void unsafe_arena_set_allocated_peer(
      ::common::v1::Peer* peer);
  ::common::v1::Peer* unsafe_arena_release_peer();

  // .common.v1.MessageItem message = 2 [json_name = "message"];
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::common::v1::MessageItem& message() const;
  PROTOBUF_NODISCARD ::common::v1::MessageItem* release_message();
  ::common::v1::MessageItem* mutable_message();
  void set_allocated_message(::common::v1::MessageItem* message);
  private:
  const ::common::v1::MessageItem& _internal_message() const;
  ::common::v1::MessageItem* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::common::v1::MessageItem* message);
  ::common::v1::MessageItem* unsafe_arena_release_message();

  // @@protoc_insertion_point(class_scope:node.highway.v1.SendExchangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::SupplyItem > items_;
  ::common::v1::Peer* peer_;
  ::common::v1::MessageItem* message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class CacheRecordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.CacheRecordRequest) */ {
 public:
  inline CacheRecordRequest() : CacheRecordRequest(nullptr) {}
  ~CacheRecordRequest() override;
  explicit constexpr CacheRecordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheRecordRequest(const CacheRecordRequest& from);
  CacheRecordRequest(CacheRecordRequest&& from) noexcept
    : CacheRecordRequest() {
    *this = ::std::move(from);
  }

  inline CacheRecordRequest& operator=(const CacheRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheRecordRequest& operator=(CacheRecordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheRecordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheRecordRequest* internal_default_instance() {
    return reinterpret_cast<const CacheRecordRequest*>(
               &_CacheRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CacheRecordRequest& a, CacheRecordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheRecordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheRecordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheRecordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheRecordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheRecordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CacheRecordRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheRecordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.CacheRecordRequest";
  }
  protected:
  explicit CacheRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kFingerprintFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string prefix = 2 [json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string fingerprint = 3 [json_name = "fingerprint"];
  void clear_fingerprint();
  const std::string& fingerprint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fingerprint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* fingerprint);
  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(const std::string& value);
  std::string* _internal_mutable_fingerprint();
  public:

  // string public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.CacheRecordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class GetRecordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.GetRecordRequest) */ {
 public:
  inline GetRecordRequest() : GetRecordRequest(nullptr) {}
  ~GetRecordRequest() override;
  explicit constexpr GetRecordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRecordRequest(const GetRecordRequest& from);
  GetRecordRequest(GetRecordRequest&& from) noexcept
    : GetRecordRequest() {
    *this = ::std::move(from);
  }

  inline GetRecordRequest& operator=(const GetRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecordRequest& operator=(GetRecordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRecordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRecordRequest* internal_default_instance() {
    return reinterpret_cast<const GetRecordRequest*>(
               &_GetRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetRecordRequest& a, GetRecordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRecordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRecordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRecordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRecordRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.GetRecordRequest";
  }
  protected:
  explicit GetRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kFingerprintFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string prefix = 2 [json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string fingerprint = 3 [json_name = "fingerprint"];
  void clear_fingerprint();
  const std::string& fingerprint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fingerprint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* fingerprint);
  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(const std::string& value);
  std::string* _internal_mutable_fingerprint();
  public:

  // string public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.GetRecordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class StoreRecordRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.StoreRecordRequest) */ {
 public:
  inline StoreRecordRequest() : StoreRecordRequest(nullptr) {}
  ~StoreRecordRequest() override;
  explicit constexpr StoreRecordRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreRecordRequest(const StoreRecordRequest& from);
  StoreRecordRequest(StoreRecordRequest&& from) noexcept
    : StoreRecordRequest() {
    *this = ::std::move(from);
  }

  inline StoreRecordRequest& operator=(const StoreRecordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreRecordRequest& operator=(StoreRecordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreRecordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreRecordRequest* internal_default_instance() {
    return reinterpret_cast<const StoreRecordRequest*>(
               &_StoreRecordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StoreRecordRequest& a, StoreRecordRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreRecordRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreRecordRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreRecordRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreRecordRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreRecordRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreRecordRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreRecordRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.StoreRecordRequest";
  }
  protected:
  explicit StoreRecordRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kFingerprintFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string prefix = 2 [json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string fingerprint = 3 [json_name = "fingerprint"];
  void clear_fingerprint();
  const std::string& fingerprint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fingerprint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* fingerprint);
  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(const std::string& value);
  std::string* _internal_mutable_fingerprint();
  public:

  // string public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.StoreRecordRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class RegisterNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.RegisterNameRequest) */ {
 public:
  inline RegisterNameRequest() : RegisterNameRequest(nullptr) {}
  ~RegisterNameRequest() override;
  explicit constexpr RegisterNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterNameRequest(const RegisterNameRequest& from);
  RegisterNameRequest(RegisterNameRequest&& from) noexcept
    : RegisterNameRequest() {
    *this = ::std::move(from);
  }

  inline RegisterNameRequest& operator=(const RegisterNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNameRequest& operator=(RegisterNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNameRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterNameRequest*>(
               &_RegisterNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RegisterNameRequest& a, RegisterNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterNameRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterNameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.RegisterNameRequest";
  }
  protected:
  explicit RegisterNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kFingerprintFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string prefix = 2 [json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string fingerprint = 3 [json_name = "fingerprint"];
  void clear_fingerprint();
  const std::string& fingerprint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fingerprint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* fingerprint);
  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(const std::string& value);
  std::string* _internal_mutable_fingerprint();
  public:

  // string public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.RegisterNameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// -------------------------------------------------------------------

class VerifyNameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.VerifyNameRequest) */ {
 public:
  inline VerifyNameRequest() : VerifyNameRequest(nullptr) {}
  ~VerifyNameRequest() override;
  explicit constexpr VerifyNameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyNameRequest(const VerifyNameRequest& from);
  VerifyNameRequest(VerifyNameRequest&& from) noexcept
    : VerifyNameRequest() {
    *this = ::std::move(from);
  }

  inline VerifyNameRequest& operator=(const VerifyNameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyNameRequest& operator=(VerifyNameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyNameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyNameRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyNameRequest*>(
               &_VerifyNameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VerifyNameRequest& a, VerifyNameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyNameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyNameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyNameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyNameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyNameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyNameRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyNameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.VerifyNameRequest";
  }
  protected:
  explicit VerifyNameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSNameFieldNumber = 1,
    kPrefixFieldNumber = 2,
    kFingerprintFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
  };
  // string s_name = 1 [json_name = "sName"];
  void clear_s_name();
  const std::string& s_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s_name();
  PROTOBUF_NODISCARD std::string* release_s_name();
  void set_allocated_s_name(std::string* s_name);
  private:
  const std::string& _internal_s_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s_name(const std::string& value);
  std::string* _internal_mutable_s_name();
  public:

  // string prefix = 2 [json_name = "prefix"];
  void clear_prefix();
  const std::string& prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prefix();
  PROTOBUF_NODISCARD std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);
  private:
  const std::string& _internal_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const std::string& value);
  std::string* _internal_mutable_prefix();
  public:

  // string fingerprint = 3 [json_name = "fingerprint"];
  void clear_fingerprint();
  const std::string& fingerprint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fingerprint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fingerprint();
  PROTOBUF_NODISCARD std::string* release_fingerprint();
  void set_allocated_fingerprint(std::string* fingerprint);
  private:
  const std::string& _internal_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fingerprint(const std::string& value);
  std::string* _internal_mutable_fingerprint();
  public:

  // string public_key = 4 [json_name = "publicKey"];
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_NODISCARD std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.VerifyNameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fingerprint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2frequest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateChannelRequest

// string name = 1 [json_name = "name"];
inline void CreateChannelRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateChannelRequest::name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CreateChannelRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChannelRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CreateChannelRequest.name)
}
inline std::string* CreateChannelRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CreateChannelRequest.name)
  return _s;
}
inline const std::string& CreateChannelRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateChannelRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateChannelRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateChannelRequest::release_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CreateChannelRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateChannelRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CreateChannelRequest.name)
}

// string description = 2 [json_name = "description"];
inline void CreateChannelRequest::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& CreateChannelRequest::description() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CreateChannelRequest.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateChannelRequest::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CreateChannelRequest.description)
}
inline std::string* CreateChannelRequest::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CreateChannelRequest.description)
  return _s;
}
inline const std::string& CreateChannelRequest::_internal_description() const {
  return description_.Get();
}
inline void CreateChannelRequest::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateChannelRequest::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateChannelRequest::release_description() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CreateChannelRequest.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateChannelRequest::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CreateChannelRequest.description)
}

// repeated string owners = 3 [json_name = "owners"];
inline int CreateChannelRequest::_internal_owners_size() const {
  return owners_.size();
}
inline int CreateChannelRequest::owners_size() const {
  return _internal_owners_size();
}
inline void CreateChannelRequest::clear_owners() {
  owners_.Clear();
}
inline std::string* CreateChannelRequest::add_owners() {
  std::string* _s = _internal_add_owners();
  // @@protoc_insertion_point(field_add_mutable:node.highway.v1.CreateChannelRequest.owners)
  return _s;
}
inline const std::string& CreateChannelRequest::_internal_owners(int index) const {
  return owners_.Get(index);
}
inline const std::string& CreateChannelRequest::owners(int index) const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CreateChannelRequest.owners)
  return _internal_owners(index);
}
inline std::string* CreateChannelRequest::mutable_owners(int index) {
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CreateChannelRequest.owners)
  return owners_.Mutable(index);
}
inline void CreateChannelRequest::set_owners(int index, const std::string& value) {
  owners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::set_owners(int index, std::string&& value) {
  owners_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::set_owners(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  owners_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::set_owners(int index, const char* value, size_t size) {
  owners_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:node.highway.v1.CreateChannelRequest.owners)
}
inline std::string* CreateChannelRequest::_internal_add_owners() {
  return owners_.Add();
}
inline void CreateChannelRequest::add_owners(const std::string& value) {
  owners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::add_owners(std::string&& value) {
  owners_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::add_owners(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  owners_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:node.highway.v1.CreateChannelRequest.owners)
}
inline void CreateChannelRequest::add_owners(const char* value, size_t size) {
  owners_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:node.highway.v1.CreateChannelRequest.owners)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateChannelRequest::owners() const {
  // @@protoc_insertion_point(field_list:node.highway.v1.CreateChannelRequest.owners)
  return owners_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateChannelRequest::mutable_owners() {
  // @@protoc_insertion_point(field_mutable_list:node.highway.v1.CreateChannelRequest.owners)
  return &owners_;
}

// -------------------------------------------------------------------

// SubscribeChannelRequest

// string did = 1 [json_name = "did"];
inline void SubscribeChannelRequest::clear_did() {
  did_.ClearToEmpty();
}
inline const std::string& SubscribeChannelRequest::did() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SubscribeChannelRequest.did)
  return _internal_did();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SubscribeChannelRequest::set_did(ArgT0&& arg0, ArgT... args) {
 
 did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.SubscribeChannelRequest.did)
}
inline std::string* SubscribeChannelRequest::mutable_did() {
  std::string* _s = _internal_mutable_did();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SubscribeChannelRequest.did)
  return _s;
}
inline const std::string& SubscribeChannelRequest::_internal_did() const {
  return did_.Get();
}
inline void SubscribeChannelRequest::_internal_set_did(const std::string& value) {
  
  did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SubscribeChannelRequest::_internal_mutable_did() {
  
  return did_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SubscribeChannelRequest::release_did() {
  // @@protoc_insertion_point(field_release:node.highway.v1.SubscribeChannelRequest.did)
  return did_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SubscribeChannelRequest::set_allocated_did(std::string* did) {
  if (did != nullptr) {
    
  } else {
    
  }
  did_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), did,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (did_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    did_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.SubscribeChannelRequest.did)
}

// -------------------------------------------------------------------

// UnsubscribeChannelRequest

// string did = 1 [json_name = "did"];
inline void UnsubscribeChannelRequest::clear_did() {
  did_.ClearToEmpty();
}
inline const std::string& UnsubscribeChannelRequest::did() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.UnsubscribeChannelRequest.did)
  return _internal_did();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UnsubscribeChannelRequest::set_did(ArgT0&& arg0, ArgT... args) {
 
 did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.UnsubscribeChannelRequest.did)
}
inline std::string* UnsubscribeChannelRequest::mutable_did() {
  std::string* _s = _internal_mutable_did();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.UnsubscribeChannelRequest.did)
  return _s;
}
inline const std::string& UnsubscribeChannelRequest::_internal_did() const {
  return did_.Get();
}
inline void UnsubscribeChannelRequest::_internal_set_did(const std::string& value) {
  
  did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UnsubscribeChannelRequest::_internal_mutable_did() {
  
  return did_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UnsubscribeChannelRequest::release_did() {
  // @@protoc_insertion_point(field_release:node.highway.v1.UnsubscribeChannelRequest.did)
  return did_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UnsubscribeChannelRequest::set_allocated_did(std::string* did) {
  if (did != nullptr) {
    
  } else {
    
  }
  did_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), did,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (did_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    did_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.UnsubscribeChannelRequest.did)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// UpdateChannelRequest

// string did = 1 [json_name = "did"];
inline void UpdateChannelRequest::clear_did() {
  did_.ClearToEmpty();
}
inline const std::string& UpdateChannelRequest::did() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.UpdateChannelRequest.did)
  return _internal_did();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateChannelRequest::set_did(ArgT0&& arg0, ArgT... args) {
 
 did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.UpdateChannelRequest.did)
}
inline std::string* UpdateChannelRequest::mutable_did() {
  std::string* _s = _internal_mutable_did();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.UpdateChannelRequest.did)
  return _s;
}
inline const std::string& UpdateChannelRequest::_internal_did() const {
  return did_.Get();
}
inline void UpdateChannelRequest::_internal_set_did(const std::string& value) {
  
  did_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* UpdateChannelRequest::_internal_mutable_did() {
  
  return did_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* UpdateChannelRequest::release_did() {
  // @@protoc_insertion_point(field_release:node.highway.v1.UpdateChannelRequest.did)
  return did_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void UpdateChannelRequest::set_allocated_did(std::string* did) {
  if (did != nullptr) {
    
  } else {
    
  }
  did_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), did,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (did_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    did_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.UpdateChannelRequest.did)
}

// map<string, string> metadata = 2 [json_name = "metadata"];
inline int UpdateChannelRequest::_internal_metadata_size() const {
  return metadata_.size();
}
inline int UpdateChannelRequest::metadata_size() const {
  return _internal_metadata_size();
}
inline void UpdateChannelRequest::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateChannelRequest::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
UpdateChannelRequest::metadata() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.UpdateChannelRequest.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateChannelRequest::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
UpdateChannelRequest::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.UpdateChannelRequest.metadata)
  return _internal_mutable_metadata();
}

// -------------------------------------------------------------------

// ListPeersRequest

// string s_name = 1 [json_name = "sName"];
inline void ListPeersRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& ListPeersRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPeersRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.ListPeersRequest.s_name)
}
inline std::string* ListPeersRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.ListPeersRequest.s_name)
  return _s;
}
inline const std::string& ListPeersRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void ListPeersRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.ListPeersRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPeersRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.ListPeersRequest.s_name)
}

// string mnemonic = 2 [json_name = "mnemonic"];
inline void ListPeersRequest::clear_mnemonic() {
  mnemonic_.ClearToEmpty();
}
inline const std::string& ListPeersRequest::mnemonic() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersRequest.mnemonic)
  return _internal_mnemonic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPeersRequest::set_mnemonic(ArgT0&& arg0, ArgT... args) {
 
 mnemonic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.ListPeersRequest.mnemonic)
}
inline std::string* ListPeersRequest::mutable_mnemonic() {
  std::string* _s = _internal_mutable_mnemonic();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.ListPeersRequest.mnemonic)
  return _s;
}
inline const std::string& ListPeersRequest::_internal_mnemonic() const {
  return mnemonic_.Get();
}
inline void ListPeersRequest::_internal_set_mnemonic(const std::string& value) {
  
  mnemonic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::_internal_mutable_mnemonic() {
  
  return mnemonic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::release_mnemonic() {
  // @@protoc_insertion_point(field_release:node.highway.v1.ListPeersRequest.mnemonic)
  return mnemonic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPeersRequest::set_allocated_mnemonic(std::string* mnemonic) {
  if (mnemonic != nullptr) {
    
  } else {
    
  }
  mnemonic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mnemonic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mnemonic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mnemonic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.ListPeersRequest.mnemonic)
}

// string device_id = 3 [json_name = "deviceId"];
inline void ListPeersRequest::clear_device_id() {
  device_id_.ClearToEmpty();
}
inline const std::string& ListPeersRequest::device_id() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersRequest.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPeersRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.ListPeersRequest.device_id)
}
inline std::string* ListPeersRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.ListPeersRequest.device_id)
  return _s;
}
inline const std::string& ListPeersRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void ListPeersRequest::_internal_set_device_id(const std::string& value) {
  
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::_internal_mutable_device_id() {
  
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPeersRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:node.highway.v1.ListPeersRequest.device_id)
  return device_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPeersRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.ListPeersRequest.device_id)
}

// -------------------------------------------------------------------

// DecideExchangeRequest

// string s_name = 1 [json_name = "sName"];
inline void DecideExchangeRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& DecideExchangeRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecideExchangeRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeRequest.s_name)
}
inline std::string* DecideExchangeRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.DecideExchangeRequest.s_name)
  return _s;
}
inline const std::string& DecideExchangeRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void DecideExchangeRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.DecideExchangeRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecideExchangeRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.DecideExchangeRequest.s_name)
}

// string mnemonic = 2 [json_name = "mnemonic"];
inline void DecideExchangeRequest::clear_mnemonic() {
  mnemonic_.ClearToEmpty();
}
inline const std::string& DecideExchangeRequest::mnemonic() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeRequest.mnemonic)
  return _internal_mnemonic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecideExchangeRequest::set_mnemonic(ArgT0&& arg0, ArgT... args) {
 
 mnemonic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeRequest.mnemonic)
}
inline std::string* DecideExchangeRequest::mutable_mnemonic() {
  std::string* _s = _internal_mutable_mnemonic();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.DecideExchangeRequest.mnemonic)
  return _s;
}
inline const std::string& DecideExchangeRequest::_internal_mnemonic() const {
  return mnemonic_.Get();
}
inline void DecideExchangeRequest::_internal_set_mnemonic(const std::string& value) {
  
  mnemonic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::_internal_mutable_mnemonic() {
  
  return mnemonic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::release_mnemonic() {
  // @@protoc_insertion_point(field_release:node.highway.v1.DecideExchangeRequest.mnemonic)
  return mnemonic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecideExchangeRequest::set_allocated_mnemonic(std::string* mnemonic) {
  if (mnemonic != nullptr) {
    
  } else {
    
  }
  mnemonic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mnemonic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mnemonic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mnemonic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.DecideExchangeRequest.mnemonic)
}

// string device_id = 3 [json_name = "deviceId"];
inline void DecideExchangeRequest::clear_device_id() {
  device_id_.ClearToEmpty();
}
inline const std::string& DecideExchangeRequest::device_id() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeRequest.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecideExchangeRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeRequest.device_id)
}
inline std::string* DecideExchangeRequest::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.DecideExchangeRequest.device_id)
  return _s;
}
inline const std::string& DecideExchangeRequest::_internal_device_id() const {
  return device_id_.Get();
}
inline void DecideExchangeRequest::_internal_set_device_id(const std::string& value) {
  
  device_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::_internal_mutable_device_id() {
  
  return device_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecideExchangeRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:node.highway.v1.DecideExchangeRequest.device_id)
  return device_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecideExchangeRequest::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  device_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.DecideExchangeRequest.device_id)
}

// .node.highway.v1.DecideExchangeRequest.Method method = 4 [json_name = "method"];
inline void DecideExchangeRequest::clear_method() {
  method_ = 0;
}
inline ::node::highway::v1::DecideExchangeRequest_Method DecideExchangeRequest::_internal_method() const {
  return static_cast< ::node::highway::v1::DecideExchangeRequest_Method >(method_);
}
inline ::node::highway::v1::DecideExchangeRequest_Method DecideExchangeRequest::method() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeRequest.method)
  return _internal_method();
}
inline void DecideExchangeRequest::_internal_set_method(::node::highway::v1::DecideExchangeRequest_Method value) {
  
  method_ = value;
}
inline void DecideExchangeRequest::set_method(::node::highway::v1::DecideExchangeRequest_Method value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeRequest.method)
}

// -------------------------------------------------------------------

// SendExchangeRequest

// .common.v1.Peer peer = 1 [json_name = "peer"];
inline bool SendExchangeRequest::_internal_has_peer() const {
  return this != internal_default_instance() && peer_ != nullptr;
}
inline bool SendExchangeRequest::has_peer() const {
  return _internal_has_peer();
}
inline const ::common::v1::Peer& SendExchangeRequest::_internal_peer() const {
  const ::common::v1::Peer* p = peer_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Peer&>(
      ::common::v1::_Peer_default_instance_);
}
inline const ::common::v1::Peer& SendExchangeRequest::peer() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SendExchangeRequest.peer)
  return _internal_peer();
}
inline void SendExchangeRequest::unsafe_arena_set_allocated_peer(
    ::common::v1::Peer* peer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  peer_ = peer;
  if (peer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.SendExchangeRequest.peer)
}
inline ::common::v1::Peer* SendExchangeRequest::release_peer() {
  
  ::common::v1::Peer* temp = peer_;
  peer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Peer* SendExchangeRequest::unsafe_arena_release_peer() {
  // @@protoc_insertion_point(field_release:node.highway.v1.SendExchangeRequest.peer)
  
  ::common::v1::Peer* temp = peer_;
  peer_ = nullptr;
  return temp;
}
inline ::common::v1::Peer* SendExchangeRequest::_internal_mutable_peer() {
  
  if (peer_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Peer>(GetArenaForAllocation());
    peer_ = p;
  }
  return peer_;
}
inline ::common::v1::Peer* SendExchangeRequest::mutable_peer() {
  ::common::v1::Peer* _msg = _internal_mutable_peer();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SendExchangeRequest.peer)
  return _msg;
}
inline void SendExchangeRequest::set_allocated_peer(::common::v1::Peer* peer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer_);
  }
  if (peer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(peer));
    if (message_arena != submessage_arena) {
      peer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.SendExchangeRequest.peer)
}

// .common.v1.MessageItem message = 2 [json_name = "message"];
inline bool SendExchangeRequest::_internal_has_message() const {
  return this != internal_default_instance() && message_ != nullptr;
}
inline bool SendExchangeRequest::has_message() const {
  return _internal_has_message();
}
inline const ::common::v1::MessageItem& SendExchangeRequest::_internal_message() const {
  const ::common::v1::MessageItem* p = message_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::MessageItem&>(
      ::common::v1::_MessageItem_default_instance_);
}
inline const ::common::v1::MessageItem& SendExchangeRequest::message() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SendExchangeRequest.message)
  return _internal_message();
}
inline void SendExchangeRequest::unsafe_arena_set_allocated_message(
    ::common::v1::MessageItem* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.SendExchangeRequest.message)
}
inline ::common::v1::MessageItem* SendExchangeRequest::release_message() {
  
  ::common::v1::MessageItem* temp = message_;
  message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::MessageItem* SendExchangeRequest::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:node.highway.v1.SendExchangeRequest.message)
  
  ::common::v1::MessageItem* temp = message_;
  message_ = nullptr;
  return temp;
}
inline ::common::v1::MessageItem* SendExchangeRequest::_internal_mutable_message() {
  
  if (message_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::MessageItem>(GetArenaForAllocation());
    message_ = p;
  }
  return message_;
}
inline ::common::v1::MessageItem* SendExchangeRequest::mutable_message() {
  ::common::v1::MessageItem* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SendExchangeRequest.message)
  return _msg;
}
inline void SendExchangeRequest::set_allocated_message(::common::v1::MessageItem* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(message_);
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(message));
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  message_ = message;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.SendExchangeRequest.message)
}

// repeated .common.v1.SupplyItem items = 3 [json_name = "items"];
inline int SendExchangeRequest::_internal_items_size() const {
  return items_.size();
}
inline int SendExchangeRequest::items_size() const {
  return _internal_items_size();
}
inline ::common::v1::SupplyItem* SendExchangeRequest::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SendExchangeRequest.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::SupplyItem >*
SendExchangeRequest::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:node.highway.v1.SendExchangeRequest.items)
  return &items_;
}
inline const ::common::v1::SupplyItem& SendExchangeRequest::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::common::v1::SupplyItem& SendExchangeRequest::items(int index) const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SendExchangeRequest.items)
  return _internal_items(index);
}
inline ::common::v1::SupplyItem* SendExchangeRequest::_internal_add_items() {
  return items_.Add();
}
inline ::common::v1::SupplyItem* SendExchangeRequest::add_items() {
  ::common::v1::SupplyItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:node.highway.v1.SendExchangeRequest.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::SupplyItem >&
SendExchangeRequest::items() const {
  // @@protoc_insertion_point(field_list:node.highway.v1.SendExchangeRequest.items)
  return items_;
}

// -------------------------------------------------------------------

// CacheRecordRequest

// string s_name = 1 [json_name = "sName"];
inline void CacheRecordRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& CacheRecordRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRecordRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordRequest.s_name)
}
inline std::string* CacheRecordRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CacheRecordRequest.s_name)
  return _s;
}
inline const std::string& CacheRecordRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void CacheRecordRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CacheRecordRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CacheRecordRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CacheRecordRequest.s_name)
}

// string prefix = 2 [json_name = "prefix"];
inline void CacheRecordRequest::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& CacheRecordRequest::prefix() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordRequest.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRecordRequest::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordRequest.prefix)
}
inline std::string* CacheRecordRequest::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CacheRecordRequest.prefix)
  return _s;
}
inline const std::string& CacheRecordRequest::_internal_prefix() const {
  return prefix_.Get();
}
inline void CacheRecordRequest::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::release_prefix() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CacheRecordRequest.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CacheRecordRequest::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CacheRecordRequest.prefix)
}

// string fingerprint = 3 [json_name = "fingerprint"];
inline void CacheRecordRequest::clear_fingerprint() {
  fingerprint_.ClearToEmpty();
}
inline const std::string& CacheRecordRequest::fingerprint() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordRequest.fingerprint)
  return _internal_fingerprint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRecordRequest::set_fingerprint(ArgT0&& arg0, ArgT... args) {
 
 fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordRequest.fingerprint)
}
inline std::string* CacheRecordRequest::mutable_fingerprint() {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CacheRecordRequest.fingerprint)
  return _s;
}
inline const std::string& CacheRecordRequest::_internal_fingerprint() const {
  return fingerprint_.Get();
}
inline void CacheRecordRequest::_internal_set_fingerprint(const std::string& value) {
  
  fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::_internal_mutable_fingerprint() {
  
  return fingerprint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::release_fingerprint() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CacheRecordRequest.fingerprint)
  return fingerprint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CacheRecordRequest::set_allocated_fingerprint(std::string* fingerprint) {
  if (fingerprint != nullptr) {
    
  } else {
    
  }
  fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fingerprint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fingerprint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fingerprint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CacheRecordRequest.fingerprint)
}

// string public_key = 4 [json_name = "publicKey"];
inline void CacheRecordRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& CacheRecordRequest::public_key() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRecordRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordRequest.public_key)
}
inline std::string* CacheRecordRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CacheRecordRequest.public_key)
  return _s;
}
inline const std::string& CacheRecordRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void CacheRecordRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheRecordRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CacheRecordRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CacheRecordRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CacheRecordRequest.public_key)
}

// -------------------------------------------------------------------

// GetRecordRequest

// string s_name = 1 [json_name = "sName"];
inline void GetRecordRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& GetRecordRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecordRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordRequest.s_name)
}
inline std::string* GetRecordRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.GetRecordRequest.s_name)
  return _s;
}
inline const std::string& GetRecordRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void GetRecordRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.GetRecordRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRecordRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.GetRecordRequest.s_name)
}

// string prefix = 2 [json_name = "prefix"];
inline void GetRecordRequest::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& GetRecordRequest::prefix() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordRequest.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecordRequest::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordRequest.prefix)
}
inline std::string* GetRecordRequest::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.GetRecordRequest.prefix)
  return _s;
}
inline const std::string& GetRecordRequest::_internal_prefix() const {
  return prefix_.Get();
}
inline void GetRecordRequest::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::release_prefix() {
  // @@protoc_insertion_point(field_release:node.highway.v1.GetRecordRequest.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRecordRequest::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.GetRecordRequest.prefix)
}

// string fingerprint = 3 [json_name = "fingerprint"];
inline void GetRecordRequest::clear_fingerprint() {
  fingerprint_.ClearToEmpty();
}
inline const std::string& GetRecordRequest::fingerprint() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordRequest.fingerprint)
  return _internal_fingerprint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecordRequest::set_fingerprint(ArgT0&& arg0, ArgT... args) {
 
 fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordRequest.fingerprint)
}
inline std::string* GetRecordRequest::mutable_fingerprint() {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.GetRecordRequest.fingerprint)
  return _s;
}
inline const std::string& GetRecordRequest::_internal_fingerprint() const {
  return fingerprint_.Get();
}
inline void GetRecordRequest::_internal_set_fingerprint(const std::string& value) {
  
  fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::_internal_mutable_fingerprint() {
  
  return fingerprint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::release_fingerprint() {
  // @@protoc_insertion_point(field_release:node.highway.v1.GetRecordRequest.fingerprint)
  return fingerprint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRecordRequest::set_allocated_fingerprint(std::string* fingerprint) {
  if (fingerprint != nullptr) {
    
  } else {
    
  }
  fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fingerprint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fingerprint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fingerprint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.GetRecordRequest.fingerprint)
}

// string public_key = 4 [json_name = "publicKey"];
inline void GetRecordRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& GetRecordRequest::public_key() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecordRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordRequest.public_key)
}
inline std::string* GetRecordRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.GetRecordRequest.public_key)
  return _s;
}
inline const std::string& GetRecordRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void GetRecordRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRecordRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:node.highway.v1.GetRecordRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRecordRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.GetRecordRequest.public_key)
}

// -------------------------------------------------------------------

// StoreRecordRequest

// string s_name = 1 [json_name = "sName"];
inline void StoreRecordRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& StoreRecordRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRecordRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordRequest.s_name)
}
inline std::string* StoreRecordRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.StoreRecordRequest.s_name)
  return _s;
}
inline const std::string& StoreRecordRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void StoreRecordRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.StoreRecordRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRecordRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.StoreRecordRequest.s_name)
}

// string prefix = 2 [json_name = "prefix"];
inline void StoreRecordRequest::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& StoreRecordRequest::prefix() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordRequest.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRecordRequest::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordRequest.prefix)
}
inline std::string* StoreRecordRequest::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.StoreRecordRequest.prefix)
  return _s;
}
inline const std::string& StoreRecordRequest::_internal_prefix() const {
  return prefix_.Get();
}
inline void StoreRecordRequest::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::release_prefix() {
  // @@protoc_insertion_point(field_release:node.highway.v1.StoreRecordRequest.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRecordRequest::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.StoreRecordRequest.prefix)
}

// string fingerprint = 3 [json_name = "fingerprint"];
inline void StoreRecordRequest::clear_fingerprint() {
  fingerprint_.ClearToEmpty();
}
inline const std::string& StoreRecordRequest::fingerprint() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordRequest.fingerprint)
  return _internal_fingerprint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRecordRequest::set_fingerprint(ArgT0&& arg0, ArgT... args) {
 
 fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordRequest.fingerprint)
}
inline std::string* StoreRecordRequest::mutable_fingerprint() {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.StoreRecordRequest.fingerprint)
  return _s;
}
inline const std::string& StoreRecordRequest::_internal_fingerprint() const {
  return fingerprint_.Get();
}
inline void StoreRecordRequest::_internal_set_fingerprint(const std::string& value) {
  
  fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::_internal_mutable_fingerprint() {
  
  return fingerprint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::release_fingerprint() {
  // @@protoc_insertion_point(field_release:node.highway.v1.StoreRecordRequest.fingerprint)
  return fingerprint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRecordRequest::set_allocated_fingerprint(std::string* fingerprint) {
  if (fingerprint != nullptr) {
    
  } else {
    
  }
  fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fingerprint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fingerprint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fingerprint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.StoreRecordRequest.fingerprint)
}

// string public_key = 4 [json_name = "publicKey"];
inline void StoreRecordRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& StoreRecordRequest::public_key() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRecordRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordRequest.public_key)
}
inline std::string* StoreRecordRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.StoreRecordRequest.public_key)
  return _s;
}
inline const std::string& StoreRecordRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void StoreRecordRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRecordRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:node.highway.v1.StoreRecordRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRecordRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.StoreRecordRequest.public_key)
}

// -------------------------------------------------------------------

// RegisterNameRequest

// string s_name = 1 [json_name = "sName"];
inline void RegisterNameRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& RegisterNameRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNameRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameRequest.s_name)
}
inline std::string* RegisterNameRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.RegisterNameRequest.s_name)
  return _s;
}
inline const std::string& RegisterNameRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void RegisterNameRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.RegisterNameRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterNameRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.RegisterNameRequest.s_name)
}

// string prefix = 2 [json_name = "prefix"];
inline void RegisterNameRequest::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& RegisterNameRequest::prefix() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameRequest.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNameRequest::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameRequest.prefix)
}
inline std::string* RegisterNameRequest::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.RegisterNameRequest.prefix)
  return _s;
}
inline const std::string& RegisterNameRequest::_internal_prefix() const {
  return prefix_.Get();
}
inline void RegisterNameRequest::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::release_prefix() {
  // @@protoc_insertion_point(field_release:node.highway.v1.RegisterNameRequest.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterNameRequest::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.RegisterNameRequest.prefix)
}

// string fingerprint = 3 [json_name = "fingerprint"];
inline void RegisterNameRequest::clear_fingerprint() {
  fingerprint_.ClearToEmpty();
}
inline const std::string& RegisterNameRequest::fingerprint() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameRequest.fingerprint)
  return _internal_fingerprint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNameRequest::set_fingerprint(ArgT0&& arg0, ArgT... args) {
 
 fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameRequest.fingerprint)
}
inline std::string* RegisterNameRequest::mutable_fingerprint() {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.RegisterNameRequest.fingerprint)
  return _s;
}
inline const std::string& RegisterNameRequest::_internal_fingerprint() const {
  return fingerprint_.Get();
}
inline void RegisterNameRequest::_internal_set_fingerprint(const std::string& value) {
  
  fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::_internal_mutable_fingerprint() {
  
  return fingerprint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::release_fingerprint() {
  // @@protoc_insertion_point(field_release:node.highway.v1.RegisterNameRequest.fingerprint)
  return fingerprint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterNameRequest::set_allocated_fingerprint(std::string* fingerprint) {
  if (fingerprint != nullptr) {
    
  } else {
    
  }
  fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fingerprint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fingerprint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fingerprint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.RegisterNameRequest.fingerprint)
}

// string public_key = 4 [json_name = "publicKey"];
inline void RegisterNameRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& RegisterNameRequest::public_key() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNameRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameRequest.public_key)
}
inline std::string* RegisterNameRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.RegisterNameRequest.public_key)
  return _s;
}
inline const std::string& RegisterNameRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void RegisterNameRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterNameRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:node.highway.v1.RegisterNameRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterNameRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.RegisterNameRequest.public_key)
}

// -------------------------------------------------------------------

// VerifyNameRequest

// string s_name = 1 [json_name = "sName"];
inline void VerifyNameRequest::clear_s_name() {
  s_name_.ClearToEmpty();
}
inline const std::string& VerifyNameRequest::s_name() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameRequest.s_name)
  return _internal_s_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyNameRequest::set_s_name(ArgT0&& arg0, ArgT... args) {
 
 s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameRequest.s_name)
}
inline std::string* VerifyNameRequest::mutable_s_name() {
  std::string* _s = _internal_mutable_s_name();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.VerifyNameRequest.s_name)
  return _s;
}
inline const std::string& VerifyNameRequest::_internal_s_name() const {
  return s_name_.Get();
}
inline void VerifyNameRequest::_internal_set_s_name(const std::string& value) {
  
  s_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::_internal_mutable_s_name() {
  
  return s_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::release_s_name() {
  // @@protoc_insertion_point(field_release:node.highway.v1.VerifyNameRequest.s_name)
  return s_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyNameRequest::set_allocated_s_name(std::string* s_name) {
  if (s_name != nullptr) {
    
  } else {
    
  }
  s_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), s_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (s_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    s_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.VerifyNameRequest.s_name)
}

// string prefix = 2 [json_name = "prefix"];
inline void VerifyNameRequest::clear_prefix() {
  prefix_.ClearToEmpty();
}
inline const std::string& VerifyNameRequest::prefix() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameRequest.prefix)
  return _internal_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyNameRequest::set_prefix(ArgT0&& arg0, ArgT... args) {
 
 prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameRequest.prefix)
}
inline std::string* VerifyNameRequest::mutable_prefix() {
  std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.VerifyNameRequest.prefix)
  return _s;
}
inline const std::string& VerifyNameRequest::_internal_prefix() const {
  return prefix_.Get();
}
inline void VerifyNameRequest::_internal_set_prefix(const std::string& value) {
  
  prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::_internal_mutable_prefix() {
  
  return prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::release_prefix() {
  // @@protoc_insertion_point(field_release:node.highway.v1.VerifyNameRequest.prefix)
  return prefix_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyNameRequest::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    
  } else {
    
  }
  prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.VerifyNameRequest.prefix)
}

// string fingerprint = 3 [json_name = "fingerprint"];
inline void VerifyNameRequest::clear_fingerprint() {
  fingerprint_.ClearToEmpty();
}
inline const std::string& VerifyNameRequest::fingerprint() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameRequest.fingerprint)
  return _internal_fingerprint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyNameRequest::set_fingerprint(ArgT0&& arg0, ArgT... args) {
 
 fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameRequest.fingerprint)
}
inline std::string* VerifyNameRequest::mutable_fingerprint() {
  std::string* _s = _internal_mutable_fingerprint();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.VerifyNameRequest.fingerprint)
  return _s;
}
inline const std::string& VerifyNameRequest::_internal_fingerprint() const {
  return fingerprint_.Get();
}
inline void VerifyNameRequest::_internal_set_fingerprint(const std::string& value) {
  
  fingerprint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::_internal_mutable_fingerprint() {
  
  return fingerprint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::release_fingerprint() {
  // @@protoc_insertion_point(field_release:node.highway.v1.VerifyNameRequest.fingerprint)
  return fingerprint_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyNameRequest::set_allocated_fingerprint(std::string* fingerprint) {
  if (fingerprint != nullptr) {
    
  } else {
    
  }
  fingerprint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fingerprint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fingerprint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fingerprint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.VerifyNameRequest.fingerprint)
}

// string public_key = 4 [json_name = "publicKey"];
inline void VerifyNameRequest::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& VerifyNameRequest::public_key() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameRequest.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyNameRequest::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameRequest.public_key)
}
inline std::string* VerifyNameRequest::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.VerifyNameRequest.public_key)
  return _s;
}
inline const std::string& VerifyNameRequest::_internal_public_key() const {
  return public_key_.Get();
}
inline void VerifyNameRequest::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyNameRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:node.highway.v1.VerifyNameRequest.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyNameRequest::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.VerifyNameRequest.public_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace highway
}  // namespace node

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::node::highway::v1::DecideExchangeRequest_Method> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::node::highway::v1::DecideExchangeRequest_Method>() {
  return ::node::highway::v1::DecideExchangeRequest_Method_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2frequest_2eproto
