// Code generated by protoc-gen-go-cosmos-orm. DO NOT EDIT.

package identityv1

import (
	context "context"
	ormlist "cosmossdk.io/orm/model/ormlist"
	ormtable "cosmossdk.io/orm/model/ormtable"
	ormerrors "cosmossdk.io/orm/types/ormerrors"
)

type BlockchainAccountTable interface {
	Insert(ctx context.Context, blockchainAccount *BlockchainAccount) error
	InsertReturningSequence(ctx context.Context, blockchainAccount *BlockchainAccount) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, blockchainAccount *BlockchainAccount) error
	Save(ctx context.Context, blockchainAccount *BlockchainAccount) error
	Delete(ctx context.Context, blockchainAccount *BlockchainAccount) error
	Has(ctx context.Context, sequence uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, sequence uint64) (*BlockchainAccount, error)
	HasByAddress(ctx context.Context, address string) (found bool, err error)
	// GetByAddress returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByAddress(ctx context.Context, address string) (*BlockchainAccount, error)
	HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error)
	// GetByPublicKey returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByPublicKey(ctx context.Context, public_key []byte) (*BlockchainAccount, error)
	List(ctx context.Context, prefixKey BlockchainAccountIndexKey, opts ...ormlist.Option) (BlockchainAccountIterator, error)
	ListRange(ctx context.Context, from, to BlockchainAccountIndexKey, opts ...ormlist.Option) (BlockchainAccountIterator, error)
	DeleteBy(ctx context.Context, prefixKey BlockchainAccountIndexKey) error
	DeleteRange(ctx context.Context, from, to BlockchainAccountIndexKey) error

	doNotImplement()
}

type BlockchainAccountIterator struct {
	ormtable.Iterator
}

func (i BlockchainAccountIterator) Value() (*BlockchainAccount, error) {
	var blockchainAccount BlockchainAccount
	err := i.UnmarshalMessage(&blockchainAccount)
	return &blockchainAccount, err
}

type BlockchainAccountIndexKey interface {
	id() uint32
	values() []interface{}
	blockchainAccountIndexKey()
}

// primary key starting index..
type BlockchainAccountPrimaryKey = BlockchainAccountSequenceIndexKey

type BlockchainAccountSequenceIndexKey struct {
	vs []interface{}
}

func (x BlockchainAccountSequenceIndexKey) id() uint32                 { return 0 }
func (x BlockchainAccountSequenceIndexKey) values() []interface{}      { return x.vs }
func (x BlockchainAccountSequenceIndexKey) blockchainAccountIndexKey() {}

func (this BlockchainAccountSequenceIndexKey) WithSequence(sequence uint64) BlockchainAccountSequenceIndexKey {
	this.vs = []interface{}{sequence}
	return this
}

type BlockchainAccountAddressIndexKey struct {
	vs []interface{}
}

func (x BlockchainAccountAddressIndexKey) id() uint32                 { return 1 }
func (x BlockchainAccountAddressIndexKey) values() []interface{}      { return x.vs }
func (x BlockchainAccountAddressIndexKey) blockchainAccountIndexKey() {}

func (this BlockchainAccountAddressIndexKey) WithAddress(address string) BlockchainAccountAddressIndexKey {
	this.vs = []interface{}{address}
	return this
}

type BlockchainAccountPublicKeyIndexKey struct {
	vs []interface{}
}

func (x BlockchainAccountPublicKeyIndexKey) id() uint32                 { return 2 }
func (x BlockchainAccountPublicKeyIndexKey) values() []interface{}      { return x.vs }
func (x BlockchainAccountPublicKeyIndexKey) blockchainAccountIndexKey() {}

func (this BlockchainAccountPublicKeyIndexKey) WithPublicKey(public_key []byte) BlockchainAccountPublicKeyIndexKey {
	this.vs = []interface{}{public_key}
	return this
}

type blockchainAccountTable struct {
	table ormtable.AutoIncrementTable
}

func (this blockchainAccountTable) Insert(ctx context.Context, blockchainAccount *BlockchainAccount) error {
	return this.table.Insert(ctx, blockchainAccount)
}

func (this blockchainAccountTable) Update(ctx context.Context, blockchainAccount *BlockchainAccount) error {
	return this.table.Update(ctx, blockchainAccount)
}

func (this blockchainAccountTable) Save(ctx context.Context, blockchainAccount *BlockchainAccount) error {
	return this.table.Save(ctx, blockchainAccount)
}

func (this blockchainAccountTable) Delete(ctx context.Context, blockchainAccount *BlockchainAccount) error {
	return this.table.Delete(ctx, blockchainAccount)
}

func (this blockchainAccountTable) InsertReturningSequence(ctx context.Context, blockchainAccount *BlockchainAccount) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, blockchainAccount)
}

func (this blockchainAccountTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this blockchainAccountTable) Has(ctx context.Context, sequence uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, sequence)
}

func (this blockchainAccountTable) Get(ctx context.Context, sequence uint64) (*BlockchainAccount, error) {
	var blockchainAccount BlockchainAccount
	found, err := this.table.PrimaryKey().Get(ctx, &blockchainAccount, sequence)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchainAccount, nil
}

func (this blockchainAccountTable) HasByAddress(ctx context.Context, address string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		address,
	)
}

func (this blockchainAccountTable) GetByAddress(ctx context.Context, address string) (*BlockchainAccount, error) {
	var blockchainAccount BlockchainAccount
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &blockchainAccount,
		address,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchainAccount, nil
}

func (this blockchainAccountTable) HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		public_key,
	)
}

func (this blockchainAccountTable) GetByPublicKey(ctx context.Context, public_key []byte) (*BlockchainAccount, error) {
	var blockchainAccount BlockchainAccount
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &blockchainAccount,
		public_key,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &blockchainAccount, nil
}

func (this blockchainAccountTable) List(ctx context.Context, prefixKey BlockchainAccountIndexKey, opts ...ormlist.Option) (BlockchainAccountIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return BlockchainAccountIterator{it}, err
}

func (this blockchainAccountTable) ListRange(ctx context.Context, from, to BlockchainAccountIndexKey, opts ...ormlist.Option) (BlockchainAccountIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return BlockchainAccountIterator{it}, err
}

func (this blockchainAccountTable) DeleteBy(ctx context.Context, prefixKey BlockchainAccountIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this blockchainAccountTable) DeleteRange(ctx context.Context, from, to BlockchainAccountIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this blockchainAccountTable) doNotImplement() {}

var _ BlockchainAccountTable = blockchainAccountTable{}

func NewBlockchainAccountTable(db ormtable.Schema) (BlockchainAccountTable, error) {
	table := db.GetTable(&BlockchainAccount{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&BlockchainAccount{}).ProtoReflect().Descriptor().FullName()))
	}
	return blockchainAccountTable{table.(ormtable.AutoIncrementTable)}, nil
}

type IdentityControllerTable interface {
	Insert(ctx context.Context, identityController *IdentityController) error
	InsertReturningSequence(ctx context.Context, identityController *IdentityController) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, identityController *IdentityController) error
	Save(ctx context.Context, identityController *IdentityController) error
	Delete(ctx context.Context, identityController *IdentityController) error
	Has(ctx context.Context, sequence uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, sequence uint64) (*IdentityController, error)
	HasByAddress(ctx context.Context, address string) (found bool, err error)
	// GetByAddress returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByAddress(ctx context.Context, address string) (*IdentityController, error)
	HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error)
	// GetByPublicKey returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByPublicKey(ctx context.Context, public_key []byte) (*IdentityController, error)
	HasByPeerId(ctx context.Context, peer_id string) (found bool, err error)
	// GetByPeerId returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByPeerId(ctx context.Context, peer_id string) (*IdentityController, error)
	HasByIpns(ctx context.Context, ipns string) (found bool, err error)
	// GetByIpns returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	GetByIpns(ctx context.Context, ipns string) (*IdentityController, error)
	List(ctx context.Context, prefixKey IdentityControllerIndexKey, opts ...ormlist.Option) (IdentityControllerIterator, error)
	ListRange(ctx context.Context, from, to IdentityControllerIndexKey, opts ...ormlist.Option) (IdentityControllerIterator, error)
	DeleteBy(ctx context.Context, prefixKey IdentityControllerIndexKey) error
	DeleteRange(ctx context.Context, from, to IdentityControllerIndexKey) error

	doNotImplement()
}

type IdentityControllerIterator struct {
	ormtable.Iterator
}

func (i IdentityControllerIterator) Value() (*IdentityController, error) {
	var identityController IdentityController
	err := i.UnmarshalMessage(&identityController)
	return &identityController, err
}

type IdentityControllerIndexKey interface {
	id() uint32
	values() []interface{}
	identityControllerIndexKey()
}

// primary key starting index..
type IdentityControllerPrimaryKey = IdentityControllerSequenceIndexKey

type IdentityControllerSequenceIndexKey struct {
	vs []interface{}
}

func (x IdentityControllerSequenceIndexKey) id() uint32                  { return 0 }
func (x IdentityControllerSequenceIndexKey) values() []interface{}       { return x.vs }
func (x IdentityControllerSequenceIndexKey) identityControllerIndexKey() {}

func (this IdentityControllerSequenceIndexKey) WithSequence(sequence uint64) IdentityControllerSequenceIndexKey {
	this.vs = []interface{}{sequence}
	return this
}

type IdentityControllerAddressIndexKey struct {
	vs []interface{}
}

func (x IdentityControllerAddressIndexKey) id() uint32                  { return 1 }
func (x IdentityControllerAddressIndexKey) values() []interface{}       { return x.vs }
func (x IdentityControllerAddressIndexKey) identityControllerIndexKey() {}

func (this IdentityControllerAddressIndexKey) WithAddress(address string) IdentityControllerAddressIndexKey {
	this.vs = []interface{}{address}
	return this
}

type IdentityControllerPublicKeyIndexKey struct {
	vs []interface{}
}

func (x IdentityControllerPublicKeyIndexKey) id() uint32                  { return 2 }
func (x IdentityControllerPublicKeyIndexKey) values() []interface{}       { return x.vs }
func (x IdentityControllerPublicKeyIndexKey) identityControllerIndexKey() {}

func (this IdentityControllerPublicKeyIndexKey) WithPublicKey(public_key []byte) IdentityControllerPublicKeyIndexKey {
	this.vs = []interface{}{public_key}
	return this
}

type IdentityControllerPeerIdIndexKey struct {
	vs []interface{}
}

func (x IdentityControllerPeerIdIndexKey) id() uint32                  { return 3 }
func (x IdentityControllerPeerIdIndexKey) values() []interface{}       { return x.vs }
func (x IdentityControllerPeerIdIndexKey) identityControllerIndexKey() {}

func (this IdentityControllerPeerIdIndexKey) WithPeerId(peer_id string) IdentityControllerPeerIdIndexKey {
	this.vs = []interface{}{peer_id}
	return this
}

type IdentityControllerIpnsIndexKey struct {
	vs []interface{}
}

func (x IdentityControllerIpnsIndexKey) id() uint32                  { return 4 }
func (x IdentityControllerIpnsIndexKey) values() []interface{}       { return x.vs }
func (x IdentityControllerIpnsIndexKey) identityControllerIndexKey() {}

func (this IdentityControllerIpnsIndexKey) WithIpns(ipns string) IdentityControllerIpnsIndexKey {
	this.vs = []interface{}{ipns}
	return this
}

type identityControllerTable struct {
	table ormtable.AutoIncrementTable
}

func (this identityControllerTable) Insert(ctx context.Context, identityController *IdentityController) error {
	return this.table.Insert(ctx, identityController)
}

func (this identityControllerTable) Update(ctx context.Context, identityController *IdentityController) error {
	return this.table.Update(ctx, identityController)
}

func (this identityControllerTable) Save(ctx context.Context, identityController *IdentityController) error {
	return this.table.Save(ctx, identityController)
}

func (this identityControllerTable) Delete(ctx context.Context, identityController *IdentityController) error {
	return this.table.Delete(ctx, identityController)
}

func (this identityControllerTable) InsertReturningSequence(ctx context.Context, identityController *IdentityController) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, identityController)
}

func (this identityControllerTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this identityControllerTable) Has(ctx context.Context, sequence uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, sequence)
}

func (this identityControllerTable) Get(ctx context.Context, sequence uint64) (*IdentityController, error) {
	var identityController IdentityController
	found, err := this.table.PrimaryKey().Get(ctx, &identityController, sequence)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identityController, nil
}

func (this identityControllerTable) HasByAddress(ctx context.Context, address string) (found bool, err error) {
	return this.table.GetIndexByID(1).(ormtable.UniqueIndex).Has(ctx,
		address,
	)
}

func (this identityControllerTable) GetByAddress(ctx context.Context, address string) (*IdentityController, error) {
	var identityController IdentityController
	found, err := this.table.GetIndexByID(1).(ormtable.UniqueIndex).Get(ctx, &identityController,
		address,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identityController, nil
}

func (this identityControllerTable) HasByPublicKey(ctx context.Context, public_key []byte) (found bool, err error) {
	return this.table.GetIndexByID(2).(ormtable.UniqueIndex).Has(ctx,
		public_key,
	)
}

func (this identityControllerTable) GetByPublicKey(ctx context.Context, public_key []byte) (*IdentityController, error) {
	var identityController IdentityController
	found, err := this.table.GetIndexByID(2).(ormtable.UniqueIndex).Get(ctx, &identityController,
		public_key,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identityController, nil
}

func (this identityControllerTable) HasByPeerId(ctx context.Context, peer_id string) (found bool, err error) {
	return this.table.GetIndexByID(3).(ormtable.UniqueIndex).Has(ctx,
		peer_id,
	)
}

func (this identityControllerTable) GetByPeerId(ctx context.Context, peer_id string) (*IdentityController, error) {
	var identityController IdentityController
	found, err := this.table.GetIndexByID(3).(ormtable.UniqueIndex).Get(ctx, &identityController,
		peer_id,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identityController, nil
}

func (this identityControllerTable) HasByIpns(ctx context.Context, ipns string) (found bool, err error) {
	return this.table.GetIndexByID(4).(ormtable.UniqueIndex).Has(ctx,
		ipns,
	)
}

func (this identityControllerTable) GetByIpns(ctx context.Context, ipns string) (*IdentityController, error) {
	var identityController IdentityController
	found, err := this.table.GetIndexByID(4).(ormtable.UniqueIndex).Get(ctx, &identityController,
		ipns,
	)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &identityController, nil
}

func (this identityControllerTable) List(ctx context.Context, prefixKey IdentityControllerIndexKey, opts ...ormlist.Option) (IdentityControllerIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return IdentityControllerIterator{it}, err
}

func (this identityControllerTable) ListRange(ctx context.Context, from, to IdentityControllerIndexKey, opts ...ormlist.Option) (IdentityControllerIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return IdentityControllerIterator{it}, err
}

func (this identityControllerTable) DeleteBy(ctx context.Context, prefixKey IdentityControllerIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this identityControllerTable) DeleteRange(ctx context.Context, from, to IdentityControllerIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this identityControllerTable) doNotImplement() {}

var _ IdentityControllerTable = identityControllerTable{}

func NewIdentityControllerTable(db ormtable.Schema) (IdentityControllerTable, error) {
	table := db.GetTable(&IdentityController{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&IdentityController{}).ProtoReflect().Descriptor().FullName()))
	}
	return identityControllerTable{table.(ormtable.AutoIncrementTable)}, nil
}

type TokenBalanceTable interface {
	Insert(ctx context.Context, tokenBalance *TokenBalance) error
	Update(ctx context.Context, tokenBalance *TokenBalance) error
	Save(ctx context.Context, tokenBalance *TokenBalance) error
	Delete(ctx context.Context, tokenBalance *TokenBalance) error
	Has(ctx context.Context, address string) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, address string) (*TokenBalance, error)
	List(ctx context.Context, prefixKey TokenBalanceIndexKey, opts ...ormlist.Option) (TokenBalanceIterator, error)
	ListRange(ctx context.Context, from, to TokenBalanceIndexKey, opts ...ormlist.Option) (TokenBalanceIterator, error)
	DeleteBy(ctx context.Context, prefixKey TokenBalanceIndexKey) error
	DeleteRange(ctx context.Context, from, to TokenBalanceIndexKey) error

	doNotImplement()
}

type TokenBalanceIterator struct {
	ormtable.Iterator
}

func (i TokenBalanceIterator) Value() (*TokenBalance, error) {
	var tokenBalance TokenBalance
	err := i.UnmarshalMessage(&tokenBalance)
	return &tokenBalance, err
}

type TokenBalanceIndexKey interface {
	id() uint32
	values() []interface{}
	tokenBalanceIndexKey()
}

// primary key starting index..
type TokenBalancePrimaryKey = TokenBalanceAddressIndexKey

type TokenBalanceAddressIndexKey struct {
	vs []interface{}
}

func (x TokenBalanceAddressIndexKey) id() uint32            { return 0 }
func (x TokenBalanceAddressIndexKey) values() []interface{} { return x.vs }
func (x TokenBalanceAddressIndexKey) tokenBalanceIndexKey() {}

func (this TokenBalanceAddressIndexKey) WithAddress(address string) TokenBalanceAddressIndexKey {
	this.vs = []interface{}{address}
	return this
}

type tokenBalanceTable struct {
	table ormtable.Table
}

func (this tokenBalanceTable) Insert(ctx context.Context, tokenBalance *TokenBalance) error {
	return this.table.Insert(ctx, tokenBalance)
}

func (this tokenBalanceTable) Update(ctx context.Context, tokenBalance *TokenBalance) error {
	return this.table.Update(ctx, tokenBalance)
}

func (this tokenBalanceTable) Save(ctx context.Context, tokenBalance *TokenBalance) error {
	return this.table.Save(ctx, tokenBalance)
}

func (this tokenBalanceTable) Delete(ctx context.Context, tokenBalance *TokenBalance) error {
	return this.table.Delete(ctx, tokenBalance)
}

func (this tokenBalanceTable) Has(ctx context.Context, address string) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, address)
}

func (this tokenBalanceTable) Get(ctx context.Context, address string) (*TokenBalance, error) {
	var tokenBalance TokenBalance
	found, err := this.table.PrimaryKey().Get(ctx, &tokenBalance, address)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &tokenBalance, nil
}

func (this tokenBalanceTable) List(ctx context.Context, prefixKey TokenBalanceIndexKey, opts ...ormlist.Option) (TokenBalanceIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return TokenBalanceIterator{it}, err
}

func (this tokenBalanceTable) ListRange(ctx context.Context, from, to TokenBalanceIndexKey, opts ...ormlist.Option) (TokenBalanceIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return TokenBalanceIterator{it}, err
}

func (this tokenBalanceTable) DeleteBy(ctx context.Context, prefixKey TokenBalanceIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this tokenBalanceTable) DeleteRange(ctx context.Context, from, to TokenBalanceIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this tokenBalanceTable) doNotImplement() {}

var _ TokenBalanceTable = tokenBalanceTable{}

func NewTokenBalanceTable(db ormtable.Schema) (TokenBalanceTable, error) {
	table := db.GetTable(&TokenBalance{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&TokenBalance{}).ProtoReflect().Descriptor().FullName()))
	}
	return tokenBalanceTable{table}, nil
}

type UserIdentifierTable interface {
	Insert(ctx context.Context, userIdentifier *UserIdentifier) error
	InsertReturningSequence(ctx context.Context, userIdentifier *UserIdentifier) (uint64, error)
	LastInsertedSequence(ctx context.Context) (uint64, error)
	Update(ctx context.Context, userIdentifier *UserIdentifier) error
	Save(ctx context.Context, userIdentifier *UserIdentifier) error
	Delete(ctx context.Context, userIdentifier *UserIdentifier) error
	Has(ctx context.Context, sequence uint64) (found bool, err error)
	// Get returns nil and an error which responds true to ormerrors.IsNotFound() if the record was not found.
	Get(ctx context.Context, sequence uint64) (*UserIdentifier, error)
	List(ctx context.Context, prefixKey UserIdentifierIndexKey, opts ...ormlist.Option) (UserIdentifierIterator, error)
	ListRange(ctx context.Context, from, to UserIdentifierIndexKey, opts ...ormlist.Option) (UserIdentifierIterator, error)
	DeleteBy(ctx context.Context, prefixKey UserIdentifierIndexKey) error
	DeleteRange(ctx context.Context, from, to UserIdentifierIndexKey) error

	doNotImplement()
}

type UserIdentifierIterator struct {
	ormtable.Iterator
}

func (i UserIdentifierIterator) Value() (*UserIdentifier, error) {
	var userIdentifier UserIdentifier
	err := i.UnmarshalMessage(&userIdentifier)
	return &userIdentifier, err
}

type UserIdentifierIndexKey interface {
	id() uint32
	values() []interface{}
	userIdentifierIndexKey()
}

// primary key starting index..
type UserIdentifierPrimaryKey = UserIdentifierSequenceIndexKey

type UserIdentifierSequenceIndexKey struct {
	vs []interface{}
}

func (x UserIdentifierSequenceIndexKey) id() uint32              { return 0 }
func (x UserIdentifierSequenceIndexKey) values() []interface{}   { return x.vs }
func (x UserIdentifierSequenceIndexKey) userIdentifierIndexKey() {}

func (this UserIdentifierSequenceIndexKey) WithSequence(sequence uint64) UserIdentifierSequenceIndexKey {
	this.vs = []interface{}{sequence}
	return this
}

type userIdentifierTable struct {
	table ormtable.AutoIncrementTable
}

func (this userIdentifierTable) Insert(ctx context.Context, userIdentifier *UserIdentifier) error {
	return this.table.Insert(ctx, userIdentifier)
}

func (this userIdentifierTable) Update(ctx context.Context, userIdentifier *UserIdentifier) error {
	return this.table.Update(ctx, userIdentifier)
}

func (this userIdentifierTable) Save(ctx context.Context, userIdentifier *UserIdentifier) error {
	return this.table.Save(ctx, userIdentifier)
}

func (this userIdentifierTable) Delete(ctx context.Context, userIdentifier *UserIdentifier) error {
	return this.table.Delete(ctx, userIdentifier)
}

func (this userIdentifierTable) InsertReturningSequence(ctx context.Context, userIdentifier *UserIdentifier) (uint64, error) {
	return this.table.InsertReturningPKey(ctx, userIdentifier)
}

func (this userIdentifierTable) LastInsertedSequence(ctx context.Context) (uint64, error) {
	return this.table.LastInsertedSequence(ctx)
}

func (this userIdentifierTable) Has(ctx context.Context, sequence uint64) (found bool, err error) {
	return this.table.PrimaryKey().Has(ctx, sequence)
}

func (this userIdentifierTable) Get(ctx context.Context, sequence uint64) (*UserIdentifier, error) {
	var userIdentifier UserIdentifier
	found, err := this.table.PrimaryKey().Get(ctx, &userIdentifier, sequence)
	if err != nil {
		return nil, err
	}
	if !found {
		return nil, ormerrors.NotFound
	}
	return &userIdentifier, nil
}

func (this userIdentifierTable) List(ctx context.Context, prefixKey UserIdentifierIndexKey, opts ...ormlist.Option) (UserIdentifierIterator, error) {
	it, err := this.table.GetIndexByID(prefixKey.id()).List(ctx, prefixKey.values(), opts...)
	return UserIdentifierIterator{it}, err
}

func (this userIdentifierTable) ListRange(ctx context.Context, from, to UserIdentifierIndexKey, opts ...ormlist.Option) (UserIdentifierIterator, error) {
	it, err := this.table.GetIndexByID(from.id()).ListRange(ctx, from.values(), to.values(), opts...)
	return UserIdentifierIterator{it}, err
}

func (this userIdentifierTable) DeleteBy(ctx context.Context, prefixKey UserIdentifierIndexKey) error {
	return this.table.GetIndexByID(prefixKey.id()).DeleteBy(ctx, prefixKey.values()...)
}

func (this userIdentifierTable) DeleteRange(ctx context.Context, from, to UserIdentifierIndexKey) error {
	return this.table.GetIndexByID(from.id()).DeleteRange(ctx, from.values(), to.values())
}

func (this userIdentifierTable) doNotImplement() {}

var _ UserIdentifierTable = userIdentifierTable{}

func NewUserIdentifierTable(db ormtable.Schema) (UserIdentifierTable, error) {
	table := db.GetTable(&UserIdentifier{})
	if table == nil {
		return nil, ormerrors.TableNotFound.Wrap(string((&UserIdentifier{}).ProtoReflect().Descriptor().FullName()))
	}
	return userIdentifierTable{table.(ormtable.AutoIncrementTable)}, nil
}

type StateStore interface {
	BlockchainAccountTable() BlockchainAccountTable
	IdentityControllerTable() IdentityControllerTable
	TokenBalanceTable() TokenBalanceTable
	UserIdentifierTable() UserIdentifierTable

	doNotImplement()
}

type stateStore struct {
	blockchainAccount  BlockchainAccountTable
	identityController IdentityControllerTable
	tokenBalance       TokenBalanceTable
	userIdentifier     UserIdentifierTable
}

func (x stateStore) BlockchainAccountTable() BlockchainAccountTable {
	return x.blockchainAccount
}

func (x stateStore) IdentityControllerTable() IdentityControllerTable {
	return x.identityController
}

func (x stateStore) TokenBalanceTable() TokenBalanceTable {
	return x.tokenBalance
}

func (x stateStore) UserIdentifierTable() UserIdentifierTable {
	return x.userIdentifier
}

func (stateStore) doNotImplement() {}

var _ StateStore = stateStore{}

func NewStateStore(db ormtable.Schema) (StateStore, error) {
	blockchainAccountTable, err := NewBlockchainAccountTable(db)
	if err != nil {
		return nil, err
	}

	identityControllerTable, err := NewIdentityControllerTable(db)
	if err != nil {
		return nil, err
	}

	tokenBalanceTable, err := NewTokenBalanceTable(db)
	if err != nil {
		return nil, err
	}

	userIdentifierTable, err := NewUserIdentifierTable(db)
	if err != nil {
		return nil, err
	}

	return stateStore{
		blockchainAccountTable,
		identityControllerTable,
		tokenBalanceTable,
		userIdentifierTable,
	}, nil
}
