// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service/v1/transmit.proto

// Package Transmit is utilized for direct data transmission between two peers.

package service

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	common "github.com/sonr-io/sonr/thirdparty/types/common"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// For Transfer File Payload
type FileItem struct {
	Mime         *common.MIME `protobuf:"bytes,1,opt,name=mime,proto3" json:"mime,omitempty"`
	Name         string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Path         string       `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	Size_        int64        `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	Thumbnail    *Thumbnail   `protobuf:"bytes,5,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
	LastModified int64        `protobuf:"varint,6,opt,name=last_modified,json=lastModified,proto3" json:"last_modified,omitempty"`
}

func (m *FileItem) Reset()         { *m = FileItem{} }
func (m *FileItem) String() string { return proto.CompactTextString(m) }
func (*FileItem) ProtoMessage()    {}
func (*FileItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{0}
}
func (m *FileItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileItem.Merge(m, src)
}
func (m *FileItem) XXX_Size() int {
	return m.Size()
}
func (m *FileItem) XXX_DiscardUnknown() {
	xxx_messageInfo_FileItem.DiscardUnknown(m)
}

var xxx_messageInfo_FileItem proto.InternalMessageInfo

func (m *FileItem) GetMime() *common.MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

func (m *FileItem) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *FileItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *FileItem) GetThumbnail() *Thumbnail {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

func (m *FileItem) GetLastModified() int64 {
	if m != nil {
		return m.LastModified
	}
	return 0
}

// Payload is Data thats being Passed
type Payload struct {
	Items     []*Payload_Item `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	Owner     *common.Peer    `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Size_     int64           `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	CreatedAt int64           `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}
func (*Payload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{1}
}
func (m *Payload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload.Merge(m, src)
}
func (m *Payload) XXX_Size() int {
	return m.Size()
}
func (m *Payload) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload.DiscardUnknown(m)
}

var xxx_messageInfo_Payload proto.InternalMessageInfo

func (m *Payload) GetItems() []*Payload_Item {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Payload) GetOwner() *common.Peer {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *Payload) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Payload) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// Item in Payload
type Payload_Item struct {
	Mime  *common.MIME `protobuf:"bytes,1,opt,name=mime,proto3" json:"mime,omitempty"`
	Size_ int64        `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// Attached Data
	//
	// Types that are valid to be assigned to Data:
	//	*Payload_Item_File
	//	*Payload_Item_Url
	//	*Payload_Item_Message
	Data isPayload_Item_Data `protobuf_oneof:"data"`
	// Thumbnail of the Item
	Thumbnail *Thumbnail `protobuf:"bytes,6,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *Payload_Item) Reset()         { *m = Payload_Item{} }
func (m *Payload_Item) String() string { return proto.CompactTextString(m) }
func (*Payload_Item) ProtoMessage()    {}
func (*Payload_Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{1, 0}
}
func (m *Payload_Item) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Payload_Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Payload_Item.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Payload_Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Payload_Item.Merge(m, src)
}
func (m *Payload_Item) XXX_Size() int {
	return m.Size()
}
func (m *Payload_Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Payload_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Payload_Item proto.InternalMessageInfo

type isPayload_Item_Data interface {
	isPayload_Item_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Payload_Item_File struct {
	File *FileItem `protobuf:"bytes,3,opt,name=file,proto3,oneof" json:"file,omitempty"`
}
type Payload_Item_Url struct {
	Url string `protobuf:"bytes,4,opt,name=url,proto3,oneof" json:"url,omitempty"`
}
type Payload_Item_Message struct {
	Message string `protobuf:"bytes,5,opt,name=message,proto3,oneof" json:"message,omitempty"`
}

func (*Payload_Item_File) isPayload_Item_Data()    {}
func (*Payload_Item_Url) isPayload_Item_Data()     {}
func (*Payload_Item_Message) isPayload_Item_Data() {}

func (m *Payload_Item) GetData() isPayload_Item_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Payload_Item) GetMime() *common.MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

func (m *Payload_Item) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *Payload_Item) GetFile() *FileItem {
	if x, ok := m.GetData().(*Payload_Item_File); ok {
		return x.File
	}
	return nil
}

func (m *Payload_Item) GetUrl() string {
	if x, ok := m.GetData().(*Payload_Item_Url); ok {
		return x.Url
	}
	return ""
}

func (m *Payload_Item) GetMessage() string {
	if x, ok := m.GetData().(*Payload_Item_Message); ok {
		return x.Message
	}
	return ""
}

func (m *Payload_Item) GetThumbnail() *Thumbnail {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Payload_Item) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Payload_Item_File)(nil),
		(*Payload_Item_Url)(nil),
		(*Payload_Item_Message)(nil),
	}
}

// SupplyItem is an item supplied to be a payload
type SupplyItem struct {
	Path      string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Thumbnail []byte `protobuf:"bytes,2,opt,name=thumbnail,proto3" json:"thumbnail,omitempty"`
}

func (m *SupplyItem) Reset()         { *m = SupplyItem{} }
func (m *SupplyItem) String() string { return proto.CompactTextString(m) }
func (*SupplyItem) ProtoMessage()    {}
func (*SupplyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{2}
}
func (m *SupplyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SupplyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SupplyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SupplyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SupplyItem.Merge(m, src)
}
func (m *SupplyItem) XXX_Size() int {
	return m.Size()
}
func (m *SupplyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SupplyItem.DiscardUnknown(m)
}

var xxx_messageInfo_SupplyItem proto.InternalMessageInfo

func (m *SupplyItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *SupplyItem) GetThumbnail() []byte {
	if m != nil {
		return m.Thumbnail
	}
	return nil
}

// Thumbnail of File
type Thumbnail struct {
	Buffer []byte       `protobuf:"bytes,1,opt,name=buffer,proto3" json:"buffer,omitempty"`
	Mime   *common.MIME `protobuf:"bytes,2,opt,name=mime,proto3" json:"mime,omitempty"`
}

func (m *Thumbnail) Reset()         { *m = Thumbnail{} }
func (m *Thumbnail) String() string { return proto.CompactTextString(m) }
func (*Thumbnail) ProtoMessage()    {}
func (*Thumbnail) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{3}
}
func (m *Thumbnail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Thumbnail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Thumbnail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Thumbnail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Thumbnail.Merge(m, src)
}
func (m *Thumbnail) XXX_Size() int {
	return m.Size()
}
func (m *Thumbnail) XXX_DiscardUnknown() {
	xxx_messageInfo_Thumbnail.DiscardUnknown(m)
}

var xxx_messageInfo_Thumbnail proto.InternalMessageInfo

func (m *Thumbnail) GetBuffer() []byte {
	if m != nil {
		return m.Buffer
	}
	return nil
}

func (m *Thumbnail) GetMime() *common.MIME {
	if m != nil {
		return m.Mime
	}
	return nil
}

type Session struct {
	Direction    common.Direction `protobuf:"varint,1,opt,name=direction,proto3,enum=sonrio.common.v1.Direction" json:"direction,omitempty"`
	From         *common.Peer     `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To           *common.Peer     `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Payload      *Payload         `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	LastUpdated  int64            `protobuf:"varint,5,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	Items        []*SessionItem   `protobuf:"bytes,6,rep,name=items,proto3" json:"items,omitempty"`
	CurrentIndex int32            `protobuf:"varint,7,opt,name=current_index,json=currentIndex,proto3" json:"current_index,omitempty"`
	Results      map[int32]bool   `protobuf:"bytes,8,rep,name=results,proto3" json:"results,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Session) Reset()         { *m = Session{} }
func (m *Session) String() string { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()    {}
func (*Session) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{4}
}
func (m *Session) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Session) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Session.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Session) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Session.Merge(m, src)
}
func (m *Session) XXX_Size() int {
	return m.Size()
}
func (m *Session) XXX_DiscardUnknown() {
	xxx_messageInfo_Session.DiscardUnknown(m)
}

var xxx_messageInfo_Session proto.InternalMessageInfo

func (m *Session) GetDirection() common.Direction {
	if m != nil {
		return m.Direction
	}
	return common.Direction_DIRECTION_UNSPECIFIED
}

func (m *Session) GetFrom() *common.Peer {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Session) GetTo() *common.Peer {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *Session) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Session) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *Session) GetItems() []*SessionItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Session) GetCurrentIndex() int32 {
	if m != nil {
		return m.CurrentIndex
	}
	return 0
}

func (m *Session) GetResults() map[int32]bool {
	if m != nil {
		return m.Results
	}
	return nil
}

type SessionItem struct {
	Index     int32            `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Count     int32            `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Item      *FileItem        `protobuf:"bytes,3,opt,name=item,proto3" json:"item,omitempty"`
	Written   int64            `protobuf:"varint,4,opt,name=written,proto3" json:"written,omitempty"`
	Size_     int64            `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	TotalSize int64            `protobuf:"varint,6,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	Direction common.Direction `protobuf:"varint,7,opt,name=direction,proto3,enum=sonrio.common.v1.Direction" json:"direction,omitempty"`
	Path      string           `protobuf:"bytes,8,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *SessionItem) Reset()         { *m = SessionItem{} }
func (m *SessionItem) String() string { return proto.CompactTextString(m) }
func (*SessionItem) ProtoMessage()    {}
func (*SessionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{5}
}
func (m *SessionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionItem.Merge(m, src)
}
func (m *SessionItem) XXX_Size() int {
	return m.Size()
}
func (m *SessionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionItem.DiscardUnknown(m)
}

var xxx_messageInfo_SessionItem proto.InternalMessageInfo

func (m *SessionItem) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SessionItem) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SessionItem) GetItem() *FileItem {
	if m != nil {
		return m.Item
	}
	return nil
}

func (m *SessionItem) GetWritten() int64 {
	if m != nil {
		return m.Written
	}
	return 0
}

func (m *SessionItem) GetSize_() int64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SessionItem) GetTotalSize() int64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *SessionItem) GetDirection() common.Direction {
	if m != nil {
		return m.Direction
	}
	return common.Direction_DIRECTION_UNSPECIFIED
}

func (m *SessionItem) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SessionPayload struct {
	Payload   *Payload         `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Direction common.Direction `protobuf:"varint,2,opt,name=direction,proto3,enum=sonrio.common.v1.Direction" json:"direction,omitempty"`
}

func (m *SessionPayload) Reset()         { *m = SessionPayload{} }
func (m *SessionPayload) String() string { return proto.CompactTextString(m) }
func (*SessionPayload) ProtoMessage()    {}
func (*SessionPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_c3d93fec5a7462db, []int{6}
}
func (m *SessionPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SessionPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionPayload.Merge(m, src)
}
func (m *SessionPayload) XXX_Size() int {
	return m.Size()
}
func (m *SessionPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionPayload.DiscardUnknown(m)
}

var xxx_messageInfo_SessionPayload proto.InternalMessageInfo

func (m *SessionPayload) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SessionPayload) GetDirection() common.Direction {
	if m != nil {
		return m.Direction
	}
	return common.Direction_DIRECTION_UNSPECIFIED
}

func init() {
	proto.RegisterType((*FileItem)(nil), "sonrio.motor.service.v1.FileItem")
	proto.RegisterType((*Payload)(nil), "sonrio.motor.service.v1.Payload")
	proto.RegisterType((*Payload_Item)(nil), "sonrio.motor.service.v1.Payload.Item")
	proto.RegisterType((*SupplyItem)(nil), "sonrio.motor.service.v1.SupplyItem")
	proto.RegisterType((*Thumbnail)(nil), "sonrio.motor.service.v1.Thumbnail")
	proto.RegisterType((*Session)(nil), "sonrio.motor.service.v1.Session")
	proto.RegisterMapType((map[int32]bool)(nil), "sonrio.motor.service.v1.Session.ResultsEntry")
	proto.RegisterType((*SessionItem)(nil), "sonrio.motor.service.v1.SessionItem")
	proto.RegisterType((*SessionPayload)(nil), "sonrio.motor.service.v1.SessionPayload")
}

func init() { proto.RegisterFile("service/v1/transmit.proto", fileDescriptor_c3d93fec5a7462db) }

var fileDescriptor_c3d93fec5a7462db = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x4f, 0x6f, 0xfb, 0x34,
	0x18, 0x6e, 0x92, 0xa6, 0x69, 0xdf, 0xf6, 0x37, 0x21, 0x6b, 0x1a, 0xa1, 0x40, 0xd5, 0x65, 0x80,
	0x2a, 0xc4, 0x52, 0x56, 0x84, 0x80, 0x22, 0x21, 0x98, 0x18, 0x6c, 0x48, 0x13, 0x93, 0x07, 0x17,
	0x2e, 0x55, 0xda, 0xb8, 0xab, 0x45, 0x12, 0x47, 0x8e, 0xd3, 0x51, 0xbe, 0x00, 0x17, 0x0e, 0x7c,
	0x07, 0xbe, 0x0c, 0xc7, 0x1d, 0xe1, 0x80, 0x84, 0xb6, 0x4f, 0xc1, 0x0d, 0xd9, 0x4e, 0xba, 0x54,
	0x50, 0x95, 0xed, 0x54, 0xfb, 0xc9, 0xf3, 0xbc, 0xff, 0x5f, 0x17, 0x5e, 0xc9, 0x08, 0x5f, 0xd2,
	0x19, 0x19, 0x2e, 0x4f, 0x86, 0x82, 0x07, 0x49, 0x16, 0x53, 0xe1, 0xa7, 0x9c, 0x09, 0x86, 0x5e,
	0xce, 0x58, 0xc2, 0x29, 0xf3, 0x63, 0x26, 0x18, 0xf7, 0x0b, 0x9e, 0xbf, 0x3c, 0xe9, 0xee, 0xcf,
	0x58, 0x1c, 0xb3, 0x44, 0x4a, 0x68, 0x32, 0x67, 0x9a, 0xee, 0xfd, 0x61, 0x40, 0xf3, 0x0b, 0x1a,
	0x91, 0x0b, 0x41, 0x62, 0xf4, 0x36, 0xd4, 0x63, 0x1a, 0x13, 0xd7, 0xe8, 0x1b, 0x83, 0xf6, 0xe8,
	0xc0, 0x2f, 0x4c, 0x69, 0xa1, 0xbf, 0x3c, 0xf1, 0x2f, 0x2f, 0x2e, 0xcf, 0xb0, 0xe2, 0x20, 0x04,
	0xf5, 0x24, 0x88, 0x89, 0x6b, 0xf6, 0x8d, 0x41, 0x0b, 0xab, 0xb3, 0xc4, 0xd2, 0x40, 0x2c, 0x5c,
	0x4b, 0x63, 0xf2, 0x2c, 0xb1, 0x8c, 0xfe, 0x48, 0xdc, 0x7a, 0xdf, 0x18, 0x58, 0x58, 0x9d, 0xd1,
	0xa7, 0xd0, 0x12, 0x8b, 0x3c, 0x9e, 0x26, 0x01, 0x8d, 0x5c, 0x5b, 0x39, 0xf3, 0xfc, 0x2d, 0x71,
	0xfb, 0xdf, 0x94, 0x4c, 0xfc, 0x28, 0x42, 0x47, 0xf0, 0x22, 0x0a, 0x32, 0x31, 0x89, 0x59, 0x48,
	0xe7, 0x94, 0x84, 0x6e, 0x43, 0x99, 0xef, 0x48, 0xf0, 0xb2, 0xc0, 0xbc, 0x5f, 0x2d, 0x70, 0xae,
	0x82, 0x55, 0xc4, 0x82, 0x10, 0x7d, 0x0c, 0x36, 0x15, 0x24, 0xce, 0x5c, 0xa3, 0x6f, 0x0d, 0xda,
	0xa3, 0x37, 0xb7, 0xba, 0x2b, 0x04, 0xbe, 0x2c, 0x08, 0xd6, 0x1a, 0xf4, 0x0e, 0xd8, 0xec, 0x36,
	0x21, 0x5c, 0x25, 0xfb, 0x9f, 0x85, 0xb9, 0x22, 0x84, 0x63, 0x4d, 0x5a, 0x67, 0x6c, 0x55, 0x32,
	0x7e, 0x1d, 0x60, 0xc6, 0x49, 0x20, 0x48, 0x38, 0x09, 0x44, 0x51, 0x8b, 0x56, 0x81, 0x7c, 0x26,
	0xba, 0x7f, 0x1b, 0x50, 0x7f, 0x4e, 0x07, 0x94, 0x1f, 0xb3, 0xe2, 0xe7, 0x03, 0xa8, 0xcf, 0x69,
	0xa4, 0x7d, 0xb7, 0x47, 0x87, 0x5b, 0xb3, 0x2c, 0x5b, 0x7e, 0x5e, 0xc3, 0x4a, 0x80, 0x10, 0x58,
	0x39, 0x8f, 0x54, 0x64, 0xad, 0xf3, 0x1a, 0x96, 0x17, 0xd4, 0x05, 0x27, 0x26, 0x59, 0x16, 0xdc,
	0x10, 0xd5, 0x24, 0x89, 0x97, 0xc0, 0x66, 0x0b, 0x1b, 0xcf, 0x68, 0xe1, 0x69, 0x03, 0xea, 0x61,
	0x20, 0x02, 0xef, 0x13, 0x80, 0xeb, 0x3c, 0x4d, 0xa3, 0x95, 0x2a, 0x40, 0x39, 0x42, 0x46, 0x65,
	0x84, 0x5e, 0xab, 0xfa, 0x92, 0xd9, 0x76, 0x2a, 0x76, 0xbc, 0xaf, 0xa1, 0xb5, 0xb6, 0x8f, 0x0e,
	0xa0, 0x31, 0xcd, 0xe7, 0x73, 0xc2, 0x95, 0x81, 0x0e, 0x2e, 0x6e, 0xeb, 0xba, 0x9a, 0xbb, 0xeb,
	0xea, 0xfd, 0x69, 0x81, 0x73, 0x4d, 0xb2, 0x8c, 0xb2, 0x04, 0x7d, 0x04, 0xad, 0x90, 0x72, 0x32,
	0x13, 0x94, 0x25, 0xca, 0xe4, 0xde, 0xe8, 0xd5, 0x7f, 0x8b, 0x3f, 0x2f, 0x29, 0xf8, 0x91, 0x2d,
	0x5d, 0xce, 0x39, 0x8b, 0x77, 0xcc, 0x8c, 0xe2, 0xa0, 0xb7, 0xc0, 0x14, 0xac, 0x68, 0xda, 0x36,
	0xa6, 0x29, 0x18, 0x1a, 0x83, 0x93, 0xea, 0xf9, 0x54, 0x9d, 0x6a, 0x8f, 0xfa, 0xbb, 0xe6, 0x18,
	0x97, 0x02, 0x74, 0x08, 0x6a, 0x3b, 0x26, 0x79, 0x1a, 0xca, 0xa9, 0x53, 0x2d, 0xb5, 0x70, 0x5b,
	0x62, 0xdf, 0x6a, 0x08, 0x8d, 0xcb, 0x25, 0x69, 0xa8, 0x25, 0x79, 0x63, 0xab, 0xf1, 0xa2, 0x3c,
	0xd5, 0x1d, 0x39, 0x82, 0x17, 0xb3, 0x9c, 0x73, 0x92, 0x88, 0x09, 0x4d, 0x42, 0xf2, 0x83, 0xeb,
	0xf4, 0x8d, 0x81, 0x8d, 0x3b, 0x05, 0x78, 0x21, 0x31, 0xf4, 0x25, 0x38, 0x9c, 0x64, 0x79, 0x24,
	0x32, 0xb7, 0xa9, 0x5c, 0x1c, 0xef, 0x72, 0xe1, 0x63, 0xcd, 0x3f, 0x4b, 0x04, 0x5f, 0xe1, 0x52,
	0xdd, 0x1d, 0x43, 0xa7, 0xfa, 0x01, 0xbd, 0x04, 0xd6, 0xf7, 0x64, 0xa5, 0x3a, 0x64, 0x63, 0x79,
	0x44, 0xfb, 0x60, 0x2f, 0x83, 0x28, 0xd7, 0x2d, 0x6f, 0x62, 0x7d, 0x19, 0x9b, 0x1f, 0x1a, 0xde,
	0xcf, 0x26, 0xb4, 0x2b, 0x09, 0x48, 0xa6, 0x8e, 0x58, 0xab, 0xf5, 0x45, 0xa2, 0x33, 0x96, 0x27,
	0x42, 0xe9, 0x6d, 0xac, 0x2f, 0xe8, 0x7d, 0xa8, 0xcb, 0x74, 0xff, 0xf7, 0x7e, 0x61, 0x45, 0x47,
	0x2e, 0x38, 0xb7, 0x9c, 0x0a, 0x41, 0x92, 0x62, 0xf7, 0xcb, 0xeb, 0x7a, 0x89, 0xed, 0xcd, 0xc7,
	0x42, 0x30, 0x11, 0x44, 0x13, 0xf5, 0x45, 0xbf, 0x6c, 0x2d, 0x85, 0x5c, 0xcb, 0xcf, 0x1b, 0x33,
	0xe9, 0x3c, 0x69, 0x26, 0xcb, 0xed, 0x6a, 0x3e, 0x6e, 0x97, 0xf7, 0x93, 0x01, 0x7b, 0x45, 0x39,
	0xca, 0xc7, 0xb2, 0x32, 0x66, 0xc6, 0x53, 0xc7, 0x6c, 0x23, 0x3a, 0xf3, 0x29, 0xd1, 0x9d, 0x7e,
	0xf5, 0xdb, 0x7d, 0xcf, 0xb8, 0xbb, 0xef, 0x19, 0x7f, 0xdd, 0xf7, 0x8c, 0x5f, 0x1e, 0x7a, 0xb5,
	0xbb, 0x87, 0x5e, 0xed, 0xf7, 0x87, 0x5e, 0xed, 0xbb, 0x77, 0x6f, 0xa8, 0x58, 0xe4, 0x53, 0x69,
	0x60, 0x28, 0x6d, 0x1d, 0x53, 0xa6, 0x7e, 0x87, 0x62, 0x41, 0x79, 0x98, 0x06, 0x5c, 0xac, 0x86,
	0x62, 0x95, 0x92, 0x6c, 0x58, 0x84, 0x36, 0x6d, 0xa8, 0xbf, 0xb7, 0xf7, 0xfe, 0x09, 0x00, 0x00,
	0xff, 0xff, 0x29, 0x18, 0xb9, 0x99, 0x2a, 0x07, 0x00, 0x00,
}

func (m *FileItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastModified != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.LastModified))
		i--
		dAtA[i] = 0x30
	}
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x18
	}
	if m.Owner != nil {
		{
			size, err := m.Owner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Payload_Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Payload_Item) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Thumbnail != nil {
		{
			size, err := m.Thumbnail.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x10
	}
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Payload_Item_File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Payload_Item_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Url)
	copy(dAtA[i:], m.Url)
	i = encodeVarintTransmit(dAtA, i, uint64(len(m.Url)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *Payload_Item_Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Payload_Item_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Message)
	copy(dAtA[i:], m.Message)
	i = encodeVarintTransmit(dAtA, i, uint64(len(m.Message)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *SupplyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SupplyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SupplyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumbnail) > 0 {
		i -= len(m.Thumbnail)
		copy(dAtA[i:], m.Thumbnail)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Thumbnail)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Thumbnail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Thumbnail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Thumbnail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mime != nil {
		{
			size, err := m.Mime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Buffer) > 0 {
		i -= len(m.Buffer)
		copy(dAtA[i:], m.Buffer)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Buffer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Session) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for k := range m.Results {
			v := m.Results[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i = encodeVarintTransmit(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintTransmit(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentIndex != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.CurrentIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransmit(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.LastUpdated != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x28
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintTransmit(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x42
	}
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalSize != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x30
	}
	if m.Size_ != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if m.Written != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Written))
		i--
		dAtA[i] = 0x20
	}
	if m.Item != nil {
		{
			size, err := m.Item.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Count != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SessionPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SessionPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Direction != 0 {
		i = encodeVarintTransmit(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransmit(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransmit(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransmit(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FileItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.LastModified != 0 {
		n += 1 + sovTransmit(uint64(m.LastModified))
	}
	return n
}

func (m *Payload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTransmit(uint64(l))
		}
	}
	if m.Owner != nil {
		l = m.Owner.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTransmit(uint64(m.CreatedAt))
	}
	return n
}

func (m *Payload_Item) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	if m.Thumbnail != nil {
		l = m.Thumbnail.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Payload_Item_File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}
func (m *Payload_Item_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	n += 1 + l + sovTransmit(uint64(l))
	return n
}
func (m *Payload_Item_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Message)
	n += 1 + l + sovTransmit(uint64(l))
	return n
}
func (m *SupplyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	l = len(m.Thumbnail)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Thumbnail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Buffer)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Mime != nil {
		l = m.Mime.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *Session) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovTransmit(uint64(m.LastUpdated))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTransmit(uint64(l))
		}
	}
	if m.CurrentIndex != 0 {
		n += 1 + sovTransmit(uint64(m.CurrentIndex))
	}
	if len(m.Results) > 0 {
		for k, v := range m.Results {
			_ = k
			_ = v
			mapEntrySize := 1 + sovTransmit(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovTransmit(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SessionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovTransmit(uint64(m.Index))
	}
	if m.Count != 0 {
		n += 1 + sovTransmit(uint64(m.Count))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Written != 0 {
		n += 1 + sovTransmit(uint64(m.Written))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransmit(uint64(m.Size_))
	}
	if m.TotalSize != 0 {
		n += 1 + sovTransmit(uint64(m.TotalSize))
	}
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovTransmit(uint64(l))
	}
	return n
}

func (m *SessionPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovTransmit(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovTransmit(uint64(m.Direction))
	}
	return n
}

func sovTransmit(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransmit(x uint64) (n int) {
	return sovTransmit(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FileItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &common.MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &Thumbnail{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastModified", wireType)
			}
			m.LastModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastModified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Payload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Payload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Payload_Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Owner == nil {
				m.Owner = &common.Peer{}
			}
			if err := m.Owner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Payload_Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &common.MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FileItem{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Payload_Item_File{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Payload_Item_Url{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = &Payload_Item_Message{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumbnail == nil {
				m.Thumbnail = &Thumbnail{}
			}
			if err := m.Thumbnail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SupplyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SupplyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SupplyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumbnail", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumbnail = append(m.Thumbnail[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumbnail == nil {
				m.Thumbnail = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Thumbnail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Thumbnail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Thumbnail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buffer = append(m.Buffer[:0], dAtA[iNdEx:postIndex]...)
			if m.Buffer == nil {
				m.Buffer = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mime == nil {
				m.Mime = &common.MIME{}
			}
			if err := m.Mime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= common.Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &common.Peer{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &common.Peer{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SessionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentIndex", wireType)
			}
			m.CurrentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTransmit
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransmit
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTransmit(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTransmit
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Results[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &FileItem{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Written", wireType)
			}
			m.Written = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Written |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= common.Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransmit
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransmit
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &Payload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= common.Direction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransmit(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransmit
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransmit(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransmit
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransmit
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransmit
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransmit
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransmit
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransmit        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransmit          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransmit = fmt.Errorf("proto: unexpected end of group")
)
