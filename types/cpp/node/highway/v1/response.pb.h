// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: node/highway/v1/response.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2fresponse_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2fresponse_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/core.pb.h"
#include "node/codes/v1/response.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_node_2fhighway_2fv1_2fresponse_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_node_2fhighway_2fv1_2fresponse_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_node_2fhighway_2fv1_2fresponse_2eproto;
namespace node {
namespace highway {
namespace v1 {
class CacheRecordResponse;
struct CacheRecordResponseDefaultTypeInternal;
extern CacheRecordResponseDefaultTypeInternal _CacheRecordResponse_default_instance_;
class CacheRecordResponse_RecordsEntry_DoNotUse;
struct CacheRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern CacheRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal _CacheRecordResponse_RecordsEntry_DoNotUse_default_instance_;
class CreateChannelResponse;
struct CreateChannelResponseDefaultTypeInternal;
extern CreateChannelResponseDefaultTypeInternal _CreateChannelResponse_default_instance_;
class DecideExchangeResponse;
struct DecideExchangeResponseDefaultTypeInternal;
extern DecideExchangeResponseDefaultTypeInternal _DecideExchangeResponse_default_instance_;
class DecideExchangeResponse_RecordsEntry_DoNotUse;
struct DecideExchangeResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern DecideExchangeResponse_RecordsEntry_DoNotUseDefaultTypeInternal _DecideExchangeResponse_RecordsEntry_DoNotUse_default_instance_;
class GetRecordResponse;
struct GetRecordResponseDefaultTypeInternal;
extern GetRecordResponseDefaultTypeInternal _GetRecordResponse_default_instance_;
class GetRecordResponse_RecordsEntry_DoNotUse;
struct GetRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern GetRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal _GetRecordResponse_RecordsEntry_DoNotUse_default_instance_;
class ListPeersResponse;
struct ListPeersResponseDefaultTypeInternal;
extern ListPeersResponseDefaultTypeInternal _ListPeersResponse_default_instance_;
class RegisterNameResponse;
struct RegisterNameResponseDefaultTypeInternal;
extern RegisterNameResponseDefaultTypeInternal _RegisterNameResponse_default_instance_;
class RegisterNameResponse_RecordsEntry_DoNotUse;
struct RegisterNameResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern RegisterNameResponse_RecordsEntry_DoNotUseDefaultTypeInternal _RegisterNameResponse_RecordsEntry_DoNotUse_default_instance_;
class SendExchangeResponse;
struct SendExchangeResponseDefaultTypeInternal;
extern SendExchangeResponseDefaultTypeInternal _SendExchangeResponse_default_instance_;
class StoreRecordResponse;
struct StoreRecordResponseDefaultTypeInternal;
extern StoreRecordResponseDefaultTypeInternal _StoreRecordResponse_default_instance_;
class StoreRecordResponse_RecordsEntry_DoNotUse;
struct StoreRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern StoreRecordResponse_RecordsEntry_DoNotUseDefaultTypeInternal _StoreRecordResponse_RecordsEntry_DoNotUse_default_instance_;
class SubscribeChannelResponse;
struct SubscribeChannelResponseDefaultTypeInternal;
extern SubscribeChannelResponseDefaultTypeInternal _SubscribeChannelResponse_default_instance_;
class UnsubscribeChannelResponse;
struct UnsubscribeChannelResponseDefaultTypeInternal;
extern UnsubscribeChannelResponseDefaultTypeInternal _UnsubscribeChannelResponse_default_instance_;
class UpdateChannelResponse;
struct UpdateChannelResponseDefaultTypeInternal;
extern UpdateChannelResponseDefaultTypeInternal _UpdateChannelResponse_default_instance_;
class VerifyNameResponse;
struct VerifyNameResponseDefaultTypeInternal;
extern VerifyNameResponseDefaultTypeInternal _VerifyNameResponse_default_instance_;
class VerifyNameResponse_RecordsEntry_DoNotUse;
struct VerifyNameResponse_RecordsEntry_DoNotUseDefaultTypeInternal;
extern VerifyNameResponse_RecordsEntry_DoNotUseDefaultTypeInternal _VerifyNameResponse_RecordsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace highway
}  // namespace node
PROTOBUF_NAMESPACE_OPEN
template<> ::node::highway::v1::CacheRecordResponse* Arena::CreateMaybeMessage<::node::highway::v1::CacheRecordResponse>(Arena*);
template<> ::node::highway::v1::CacheRecordResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::CacheRecordResponse_RecordsEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::CreateChannelResponse* Arena::CreateMaybeMessage<::node::highway::v1::CreateChannelResponse>(Arena*);
template<> ::node::highway::v1::DecideExchangeResponse* Arena::CreateMaybeMessage<::node::highway::v1::DecideExchangeResponse>(Arena*);
template<> ::node::highway::v1::DecideExchangeResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::DecideExchangeResponse_RecordsEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::GetRecordResponse* Arena::CreateMaybeMessage<::node::highway::v1::GetRecordResponse>(Arena*);
template<> ::node::highway::v1::GetRecordResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::GetRecordResponse_RecordsEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::ListPeersResponse* Arena::CreateMaybeMessage<::node::highway::v1::ListPeersResponse>(Arena*);
template<> ::node::highway::v1::RegisterNameResponse* Arena::CreateMaybeMessage<::node::highway::v1::RegisterNameResponse>(Arena*);
template<> ::node::highway::v1::RegisterNameResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::RegisterNameResponse_RecordsEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::SendExchangeResponse* Arena::CreateMaybeMessage<::node::highway::v1::SendExchangeResponse>(Arena*);
template<> ::node::highway::v1::StoreRecordResponse* Arena::CreateMaybeMessage<::node::highway::v1::StoreRecordResponse>(Arena*);
template<> ::node::highway::v1::StoreRecordResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::StoreRecordResponse_RecordsEntry_DoNotUse>(Arena*);
template<> ::node::highway::v1::SubscribeChannelResponse* Arena::CreateMaybeMessage<::node::highway::v1::SubscribeChannelResponse>(Arena*);
template<> ::node::highway::v1::UnsubscribeChannelResponse* Arena::CreateMaybeMessage<::node::highway::v1::UnsubscribeChannelResponse>(Arena*);
template<> ::node::highway::v1::UpdateChannelResponse* Arena::CreateMaybeMessage<::node::highway::v1::UpdateChannelResponse>(Arena*);
template<> ::node::highway::v1::VerifyNameResponse* Arena::CreateMaybeMessage<::node::highway::v1::VerifyNameResponse>(Arena*);
template<> ::node::highway::v1::VerifyNameResponse_RecordsEntry_DoNotUse* Arena::CreateMaybeMessage<::node::highway::v1::VerifyNameResponse_RecordsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace node {
namespace highway {
namespace v1 {

// ===================================================================

class CreateChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.CreateChannelResponse) */ {
 public:
  inline CreateChannelResponse() : CreateChannelResponse(nullptr) {}
  ~CreateChannelResponse() override;
  explicit constexpr CreateChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChannelResponse(const CreateChannelResponse& from);
  CreateChannelResponse(CreateChannelResponse&& from) noexcept
    : CreateChannelResponse() {
    *this = ::std::move(from);
  }

  inline CreateChannelResponse& operator=(const CreateChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChannelResponse& operator=(CreateChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChannelResponse* internal_default_instance() {
    return reinterpret_cast<const CreateChannelResponse*>(
               &_CreateChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateChannelResponse& a, CreateChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateChannelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.CreateChannelResponse";
  }
  protected:
  explicit CreateChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::node::codes::v1::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::node::codes::v1::ResponseInfo* release_info();
  ::node::codes::v1::ResponseInfo* mutable_info();
  void set_allocated_info(::node::codes::v1::ResponseInfo* info);
  private:
  const ::node::codes::v1::ResponseInfo& _internal_info() const;
  ::node::codes::v1::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::node::codes::v1::ResponseInfo* info);
  ::node::codes::v1::ResponseInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:node.highway.v1.CreateChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::node::codes::v1::ResponseInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class SubscribeChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.SubscribeChannelResponse) */ {
 public:
  inline SubscribeChannelResponse() : SubscribeChannelResponse(nullptr) {}
  ~SubscribeChannelResponse() override;
  explicit constexpr SubscribeChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeChannelResponse(const SubscribeChannelResponse& from);
  SubscribeChannelResponse(SubscribeChannelResponse&& from) noexcept
    : SubscribeChannelResponse() {
    *this = ::std::move(from);
  }

  inline SubscribeChannelResponse& operator=(const SubscribeChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeChannelResponse& operator=(SubscribeChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeChannelResponse* internal_default_instance() {
    return reinterpret_cast<const SubscribeChannelResponse*>(
               &_SubscribeChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SubscribeChannelResponse& a, SubscribeChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeChannelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.SubscribeChannelResponse";
  }
  protected:
  explicit SubscribeChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::node::codes::v1::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::node::codes::v1::ResponseInfo* release_info();
  ::node::codes::v1::ResponseInfo* mutable_info();
  void set_allocated_info(::node::codes::v1::ResponseInfo* info);
  private:
  const ::node::codes::v1::ResponseInfo& _internal_info() const;
  ::node::codes::v1::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::node::codes::v1::ResponseInfo* info);
  ::node::codes::v1::ResponseInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:node.highway.v1.SubscribeChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::node::codes::v1::ResponseInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class UnsubscribeChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.UnsubscribeChannelResponse) */ {
 public:
  inline UnsubscribeChannelResponse() : UnsubscribeChannelResponse(nullptr) {}
  ~UnsubscribeChannelResponse() override;
  explicit constexpr UnsubscribeChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnsubscribeChannelResponse(const UnsubscribeChannelResponse& from);
  UnsubscribeChannelResponse(UnsubscribeChannelResponse&& from) noexcept
    : UnsubscribeChannelResponse() {
    *this = ::std::move(from);
  }

  inline UnsubscribeChannelResponse& operator=(const UnsubscribeChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnsubscribeChannelResponse& operator=(UnsubscribeChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnsubscribeChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnsubscribeChannelResponse* internal_default_instance() {
    return reinterpret_cast<const UnsubscribeChannelResponse*>(
               &_UnsubscribeChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UnsubscribeChannelResponse& a, UnsubscribeChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnsubscribeChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnsubscribeChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnsubscribeChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnsubscribeChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnsubscribeChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnsubscribeChannelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnsubscribeChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.UnsubscribeChannelResponse";
  }
  protected:
  explicit UnsubscribeChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::node::codes::v1::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::node::codes::v1::ResponseInfo* release_info();
  ::node::codes::v1::ResponseInfo* mutable_info();
  void set_allocated_info(::node::codes::v1::ResponseInfo* info);
  private:
  const ::node::codes::v1::ResponseInfo& _internal_info() const;
  ::node::codes::v1::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::node::codes::v1::ResponseInfo* info);
  ::node::codes::v1::ResponseInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:node.highway.v1.UnsubscribeChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::node::codes::v1::ResponseInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class UpdateChannelResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.UpdateChannelResponse) */ {
 public:
  inline UpdateChannelResponse() : UpdateChannelResponse(nullptr) {}
  ~UpdateChannelResponse() override;
  explicit constexpr UpdateChannelResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateChannelResponse(const UpdateChannelResponse& from);
  UpdateChannelResponse(UpdateChannelResponse&& from) noexcept
    : UpdateChannelResponse() {
    *this = ::std::move(from);
  }

  inline UpdateChannelResponse& operator=(const UpdateChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateChannelResponse& operator=(UpdateChannelResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateChannelResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateChannelResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateChannelResponse*>(
               &_UpdateChannelResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateChannelResponse& a, UpdateChannelResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateChannelResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateChannelResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateChannelResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateChannelResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateChannelResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateChannelResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateChannelResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.UpdateChannelResponse";
  }
  protected:
  explicit UpdateChannelResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::node::codes::v1::ResponseInfo& info() const;
  PROTOBUF_NODISCARD ::node::codes::v1::ResponseInfo* release_info();
  ::node::codes::v1::ResponseInfo* mutable_info();
  void set_allocated_info(::node::codes::v1::ResponseInfo* info);
  private:
  const ::node::codes::v1::ResponseInfo& _internal_info() const;
  ::node::codes::v1::ResponseInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::node::codes::v1::ResponseInfo* info);
  ::node::codes::v1::ResponseInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:node.highway.v1.UpdateChannelResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::node::codes::v1::ResponseInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class ListPeersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.ListPeersResponse) */ {
 public:
  inline ListPeersResponse() : ListPeersResponse(nullptr) {}
  ~ListPeersResponse() override;
  explicit constexpr ListPeersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListPeersResponse(const ListPeersResponse& from);
  ListPeersResponse(ListPeersResponse&& from) noexcept
    : ListPeersResponse() {
    *this = ::std::move(from);
  }

  inline ListPeersResponse& operator=(const ListPeersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListPeersResponse& operator=(ListPeersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListPeersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListPeersResponse* internal_default_instance() {
    return reinterpret_cast<const ListPeersResponse*>(
               &_ListPeersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ListPeersResponse& a, ListPeersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListPeersResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListPeersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListPeersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListPeersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListPeersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListPeersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListPeersResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.ListPeersResponse";
  }
  protected:
  explicit ListPeersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 2,
    kOlcFieldNumber = 1,
    kReceivedFieldNumber = 3,
  };
  // repeated .common.v1.Peer peers = 2 [json_name = "peers"];
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  ::common::v1::Peer* mutable_peers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Peer >*
      mutable_peers();
  private:
  const ::common::v1::Peer& _internal_peers(int index) const;
  ::common::v1::Peer* _internal_add_peers();
  public:
  const ::common::v1::Peer& peers(int index) const;
  ::common::v1::Peer* add_peers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Peer >&
      peers() const;

  // string olc = 1 [json_name = "olc"];
  void clear_olc();
  const std::string& olc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_olc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_olc();
  PROTOBUF_NODISCARD std::string* release_olc();
  void set_allocated_olc(std::string* olc);
  private:
  const std::string& _internal_olc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_olc(const std::string& value);
  std::string* _internal_mutable_olc();
  public:

  // int64 received = 3 [json_name = "received"];
  void clear_received();
  int64_t received() const;
  void set_received(int64_t value);
  private:
  int64_t _internal_received() const;
  void _internal_set_received(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.ListPeersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Peer > peers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr olc_;
  int64_t received_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class DecideExchangeResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DecideExchangeResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DecideExchangeResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DecideExchangeResponse_RecordsEntry_DoNotUse();
  explicit constexpr DecideExchangeResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DecideExchangeResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DecideExchangeResponse_RecordsEntry_DoNotUse& other);
  static const DecideExchangeResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DecideExchangeResponse_RecordsEntry_DoNotUse*>(&_DecideExchangeResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.DecideExchangeResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.DecideExchangeResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class DecideExchangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.DecideExchangeResponse) */ {
 public:
  inline DecideExchangeResponse() : DecideExchangeResponse(nullptr) {}
  ~DecideExchangeResponse() override;
  explicit constexpr DecideExchangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecideExchangeResponse(const DecideExchangeResponse& from);
  DecideExchangeResponse(DecideExchangeResponse&& from) noexcept
    : DecideExchangeResponse() {
    *this = ::std::move(from);
  }

  inline DecideExchangeResponse& operator=(const DecideExchangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecideExchangeResponse& operator=(DecideExchangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecideExchangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecideExchangeResponse* internal_default_instance() {
    return reinterpret_cast<const DecideExchangeResponse*>(
               &_DecideExchangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DecideExchangeResponse& a, DecideExchangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DecideExchangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecideExchangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecideExchangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecideExchangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecideExchangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecideExchangeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecideExchangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.DecideExchangeResponse";
  }
  protected:
  explicit DecideExchangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.DecideExchangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DecideExchangeResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class SendExchangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.SendExchangeResponse) */ {
 public:
  inline SendExchangeResponse() : SendExchangeResponse(nullptr) {}
  ~SendExchangeResponse() override;
  explicit constexpr SendExchangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendExchangeResponse(const SendExchangeResponse& from);
  SendExchangeResponse(SendExchangeResponse&& from) noexcept
    : SendExchangeResponse() {
    *this = ::std::move(from);
  }

  inline SendExchangeResponse& operator=(const SendExchangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendExchangeResponse& operator=(SendExchangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendExchangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendExchangeResponse* internal_default_instance() {
    return reinterpret_cast<const SendExchangeResponse*>(
               &_SendExchangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SendExchangeResponse& a, SendExchangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendExchangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendExchangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendExchangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendExchangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendExchangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendExchangeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendExchangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.SendExchangeResponse";
  }
  protected:
  explicit SendExchangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.SendExchangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class CacheRecordResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CacheRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CacheRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  CacheRecordResponse_RecordsEntry_DoNotUse();
  explicit constexpr CacheRecordResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit CacheRecordResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CacheRecordResponse_RecordsEntry_DoNotUse& other);
  static const CacheRecordResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CacheRecordResponse_RecordsEntry_DoNotUse*>(&_CacheRecordResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.CacheRecordResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.CacheRecordResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class CacheRecordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.CacheRecordResponse) */ {
 public:
  inline CacheRecordResponse() : CacheRecordResponse(nullptr) {}
  ~CacheRecordResponse() override;
  explicit constexpr CacheRecordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheRecordResponse(const CacheRecordResponse& from);
  CacheRecordResponse(CacheRecordResponse&& from) noexcept
    : CacheRecordResponse() {
    *this = ::std::move(from);
  }

  inline CacheRecordResponse& operator=(const CacheRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheRecordResponse& operator=(CacheRecordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheRecordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheRecordResponse* internal_default_instance() {
    return reinterpret_cast<const CacheRecordResponse*>(
               &_CacheRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CacheRecordResponse& a, CacheRecordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheRecordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheRecordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheRecordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheRecordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheRecordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CacheRecordResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheRecordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.CacheRecordResponse";
  }
  protected:
  explicit CacheRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.CacheRecordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CacheRecordResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class GetRecordResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  GetRecordResponse_RecordsEntry_DoNotUse();
  explicit constexpr GetRecordResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit GetRecordResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetRecordResponse_RecordsEntry_DoNotUse& other);
  static const GetRecordResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetRecordResponse_RecordsEntry_DoNotUse*>(&_GetRecordResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.GetRecordResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.GetRecordResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class GetRecordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.GetRecordResponse) */ {
 public:
  inline GetRecordResponse() : GetRecordResponse(nullptr) {}
  ~GetRecordResponse() override;
  explicit constexpr GetRecordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetRecordResponse(const GetRecordResponse& from);
  GetRecordResponse(GetRecordResponse&& from) noexcept
    : GetRecordResponse() {
    *this = ::std::move(from);
  }

  inline GetRecordResponse& operator=(const GetRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRecordResponse& operator=(GetRecordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetRecordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetRecordResponse* internal_default_instance() {
    return reinterpret_cast<const GetRecordResponse*>(
               &_GetRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetRecordResponse& a, GetRecordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRecordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetRecordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetRecordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetRecordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetRecordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetRecordResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRecordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.GetRecordResponse";
  }
  protected:
  explicit GetRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.GetRecordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetRecordResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class StoreRecordResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StoreRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StoreRecordResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StoreRecordResponse_RecordsEntry_DoNotUse();
  explicit constexpr StoreRecordResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StoreRecordResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StoreRecordResponse_RecordsEntry_DoNotUse& other);
  static const StoreRecordResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StoreRecordResponse_RecordsEntry_DoNotUse*>(&_StoreRecordResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.StoreRecordResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.StoreRecordResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class StoreRecordResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.StoreRecordResponse) */ {
 public:
  inline StoreRecordResponse() : StoreRecordResponse(nullptr) {}
  ~StoreRecordResponse() override;
  explicit constexpr StoreRecordResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreRecordResponse(const StoreRecordResponse& from);
  StoreRecordResponse(StoreRecordResponse&& from) noexcept
    : StoreRecordResponse() {
    *this = ::std::move(from);
  }

  inline StoreRecordResponse& operator=(const StoreRecordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreRecordResponse& operator=(StoreRecordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreRecordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreRecordResponse* internal_default_instance() {
    return reinterpret_cast<const StoreRecordResponse*>(
               &_StoreRecordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StoreRecordResponse& a, StoreRecordResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreRecordResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreRecordResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreRecordResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreRecordResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreRecordResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreRecordResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreRecordResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.StoreRecordResponse";
  }
  protected:
  explicit StoreRecordResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.StoreRecordResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StoreRecordResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class RegisterNameResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegisterNameResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<RegisterNameResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  RegisterNameResponse_RecordsEntry_DoNotUse();
  explicit constexpr RegisterNameResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit RegisterNameResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const RegisterNameResponse_RecordsEntry_DoNotUse& other);
  static const RegisterNameResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const RegisterNameResponse_RecordsEntry_DoNotUse*>(&_RegisterNameResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.RegisterNameResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.RegisterNameResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class RegisterNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.RegisterNameResponse) */ {
 public:
  inline RegisterNameResponse() : RegisterNameResponse(nullptr) {}
  ~RegisterNameResponse() override;
  explicit constexpr RegisterNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterNameResponse(const RegisterNameResponse& from);
  RegisterNameResponse(RegisterNameResponse&& from) noexcept
    : RegisterNameResponse() {
    *this = ::std::move(from);
  }

  inline RegisterNameResponse& operator=(const RegisterNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterNameResponse& operator=(RegisterNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterNameResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterNameResponse*>(
               &_RegisterNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RegisterNameResponse& a, RegisterNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisterNameResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterNameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.RegisterNameResponse";
  }
  protected:
  explicit RegisterNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.RegisterNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      RegisterNameResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// -------------------------------------------------------------------

class VerifyNameResponse_RecordsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VerifyNameResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<VerifyNameResponse_RecordsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  VerifyNameResponse_RecordsEntry_DoNotUse();
  explicit constexpr VerifyNameResponse_RecordsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit VerifyNameResponse_RecordsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const VerifyNameResponse_RecordsEntry_DoNotUse& other);
  static const VerifyNameResponse_RecordsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const VerifyNameResponse_RecordsEntry_DoNotUse*>(&_VerifyNameResponse_RecordsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.VerifyNameResponse.RecordsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "node.highway.v1.VerifyNameResponse.RecordsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class VerifyNameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:node.highway.v1.VerifyNameResponse) */ {
 public:
  inline VerifyNameResponse() : VerifyNameResponse(nullptr) {}
  ~VerifyNameResponse() override;
  explicit constexpr VerifyNameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyNameResponse(const VerifyNameResponse& from);
  VerifyNameResponse(VerifyNameResponse&& from) noexcept
    : VerifyNameResponse() {
    *this = ::std::move(from);
  }

  inline VerifyNameResponse& operator=(const VerifyNameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyNameResponse& operator=(VerifyNameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyNameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyNameResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyNameResponse*>(
               &_VerifyNameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VerifyNameResponse& a, VerifyNameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyNameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyNameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyNameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyNameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyNameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyNameResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyNameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "node.highway.v1.VerifyNameResponse";
  }
  protected:
  explicit VerifyNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 3,
    kErrorFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // map<string, string> records = 3 [json_name = "records"];
  int records_size() const;
  private:
  int _internal_records_size() const;
  public:
  void clear_records();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_records();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      records() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_records();

  // string error = 2 [json_name = "error"];
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // bool success = 1 [json_name = "success"];
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:node.highway.v1.VerifyNameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      VerifyNameResponse_RecordsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> records_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_node_2fhighway_2fv1_2fresponse_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateChannelResponse

// .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
inline bool CreateChannelResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool CreateChannelResponse::has_info() const {
  return _internal_has_info();
}
inline const ::node::codes::v1::ResponseInfo& CreateChannelResponse::_internal_info() const {
  const ::node::codes::v1::ResponseInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::node::codes::v1::ResponseInfo&>(
      ::node::codes::v1::_ResponseInfo_default_instance_);
}
inline const ::node::codes::v1::ResponseInfo& CreateChannelResponse::info() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CreateChannelResponse.info)
  return _internal_info();
}
inline void CreateChannelResponse::unsafe_arena_set_allocated_info(
    ::node::codes::v1::ResponseInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.CreateChannelResponse.info)
}
inline ::node::codes::v1::ResponseInfo* CreateChannelResponse::release_info() {
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::node::codes::v1::ResponseInfo* CreateChannelResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CreateChannelResponse.info)
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::node::codes::v1::ResponseInfo* CreateChannelResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::node::codes::v1::ResponseInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::node::codes::v1::ResponseInfo* CreateChannelResponse::mutable_info() {
  ::node::codes::v1::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CreateChannelResponse.info)
  return _msg;
}
inline void CreateChannelResponse::set_allocated_info(::node::codes::v1::ResponseInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CreateChannelResponse.info)
}

// -------------------------------------------------------------------

// SubscribeChannelResponse

// .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
inline bool SubscribeChannelResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool SubscribeChannelResponse::has_info() const {
  return _internal_has_info();
}
inline const ::node::codes::v1::ResponseInfo& SubscribeChannelResponse::_internal_info() const {
  const ::node::codes::v1::ResponseInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::node::codes::v1::ResponseInfo&>(
      ::node::codes::v1::_ResponseInfo_default_instance_);
}
inline const ::node::codes::v1::ResponseInfo& SubscribeChannelResponse::info() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SubscribeChannelResponse.info)
  return _internal_info();
}
inline void SubscribeChannelResponse::unsafe_arena_set_allocated_info(
    ::node::codes::v1::ResponseInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.SubscribeChannelResponse.info)
}
inline ::node::codes::v1::ResponseInfo* SubscribeChannelResponse::release_info() {
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::node::codes::v1::ResponseInfo* SubscribeChannelResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:node.highway.v1.SubscribeChannelResponse.info)
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::node::codes::v1::ResponseInfo* SubscribeChannelResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::node::codes::v1::ResponseInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::node::codes::v1::ResponseInfo* SubscribeChannelResponse::mutable_info() {
  ::node::codes::v1::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SubscribeChannelResponse.info)
  return _msg;
}
inline void SubscribeChannelResponse::set_allocated_info(::node::codes::v1::ResponseInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.SubscribeChannelResponse.info)
}

// -------------------------------------------------------------------

// UnsubscribeChannelResponse

// .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
inline bool UnsubscribeChannelResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UnsubscribeChannelResponse::has_info() const {
  return _internal_has_info();
}
inline const ::node::codes::v1::ResponseInfo& UnsubscribeChannelResponse::_internal_info() const {
  const ::node::codes::v1::ResponseInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::node::codes::v1::ResponseInfo&>(
      ::node::codes::v1::_ResponseInfo_default_instance_);
}
inline const ::node::codes::v1::ResponseInfo& UnsubscribeChannelResponse::info() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.UnsubscribeChannelResponse.info)
  return _internal_info();
}
inline void UnsubscribeChannelResponse::unsafe_arena_set_allocated_info(
    ::node::codes::v1::ResponseInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.UnsubscribeChannelResponse.info)
}
inline ::node::codes::v1::ResponseInfo* UnsubscribeChannelResponse::release_info() {
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::node::codes::v1::ResponseInfo* UnsubscribeChannelResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:node.highway.v1.UnsubscribeChannelResponse.info)
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::node::codes::v1::ResponseInfo* UnsubscribeChannelResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::node::codes::v1::ResponseInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::node::codes::v1::ResponseInfo* UnsubscribeChannelResponse::mutable_info() {
  ::node::codes::v1::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.UnsubscribeChannelResponse.info)
  return _msg;
}
inline void UnsubscribeChannelResponse::set_allocated_info(::node::codes::v1::ResponseInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.UnsubscribeChannelResponse.info)
}

// -------------------------------------------------------------------

// UpdateChannelResponse

// .node.codes.v1.ResponseInfo info = 1 [json_name = "info"];
inline bool UpdateChannelResponse::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool UpdateChannelResponse::has_info() const {
  return _internal_has_info();
}
inline const ::node::codes::v1::ResponseInfo& UpdateChannelResponse::_internal_info() const {
  const ::node::codes::v1::ResponseInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::node::codes::v1::ResponseInfo&>(
      ::node::codes::v1::_ResponseInfo_default_instance_);
}
inline const ::node::codes::v1::ResponseInfo& UpdateChannelResponse::info() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.UpdateChannelResponse.info)
  return _internal_info();
}
inline void UpdateChannelResponse::unsafe_arena_set_allocated_info(
    ::node::codes::v1::ResponseInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:node.highway.v1.UpdateChannelResponse.info)
}
inline ::node::codes::v1::ResponseInfo* UpdateChannelResponse::release_info() {
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::node::codes::v1::ResponseInfo* UpdateChannelResponse::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:node.highway.v1.UpdateChannelResponse.info)
  
  ::node::codes::v1::ResponseInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::node::codes::v1::ResponseInfo* UpdateChannelResponse::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::node::codes::v1::ResponseInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::node::codes::v1::ResponseInfo* UpdateChannelResponse::mutable_info() {
  ::node::codes::v1::ResponseInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.UpdateChannelResponse.info)
  return _msg;
}
inline void UpdateChannelResponse::set_allocated_info(::node::codes::v1::ResponseInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info));
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.UpdateChannelResponse.info)
}

// -------------------------------------------------------------------

// ListPeersResponse

// string olc = 1 [json_name = "olc"];
inline void ListPeersResponse::clear_olc() {
  olc_.ClearToEmpty();
}
inline const std::string& ListPeersResponse::olc() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersResponse.olc)
  return _internal_olc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListPeersResponse::set_olc(ArgT0&& arg0, ArgT... args) {
 
 olc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.ListPeersResponse.olc)
}
inline std::string* ListPeersResponse::mutable_olc() {
  std::string* _s = _internal_mutable_olc();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.ListPeersResponse.olc)
  return _s;
}
inline const std::string& ListPeersResponse::_internal_olc() const {
  return olc_.Get();
}
inline void ListPeersResponse::_internal_set_olc(const std::string& value) {
  
  olc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListPeersResponse::_internal_mutable_olc() {
  
  return olc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListPeersResponse::release_olc() {
  // @@protoc_insertion_point(field_release:node.highway.v1.ListPeersResponse.olc)
  return olc_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListPeersResponse::set_allocated_olc(std::string* olc) {
  if (olc != nullptr) {
    
  } else {
    
  }
  olc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), olc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (olc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    olc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.ListPeersResponse.olc)
}

// repeated .common.v1.Peer peers = 2 [json_name = "peers"];
inline int ListPeersResponse::_internal_peers_size() const {
  return peers_.size();
}
inline int ListPeersResponse::peers_size() const {
  return _internal_peers_size();
}
inline ::common::v1::Peer* ListPeersResponse::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:node.highway.v1.ListPeersResponse.peers)
  return peers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Peer >*
ListPeersResponse::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:node.highway.v1.ListPeersResponse.peers)
  return &peers_;
}
inline const ::common::v1::Peer& ListPeersResponse::_internal_peers(int index) const {
  return peers_.Get(index);
}
inline const ::common::v1::Peer& ListPeersResponse::peers(int index) const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersResponse.peers)
  return _internal_peers(index);
}
inline ::common::v1::Peer* ListPeersResponse::_internal_add_peers() {
  return peers_.Add();
}
inline ::common::v1::Peer* ListPeersResponse::add_peers() {
  ::common::v1::Peer* _add = _internal_add_peers();
  // @@protoc_insertion_point(field_add:node.highway.v1.ListPeersResponse.peers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::common::v1::Peer >&
ListPeersResponse::peers() const {
  // @@protoc_insertion_point(field_list:node.highway.v1.ListPeersResponse.peers)
  return peers_;
}

// int64 received = 3 [json_name = "received"];
inline void ListPeersResponse::clear_received() {
  received_ = int64_t{0};
}
inline int64_t ListPeersResponse::_internal_received() const {
  return received_;
}
inline int64_t ListPeersResponse::received() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.ListPeersResponse.received)
  return _internal_received();
}
inline void ListPeersResponse::_internal_set_received(int64_t value) {
  
  received_ = value;
}
inline void ListPeersResponse::set_received(int64_t value) {
  _internal_set_received(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.ListPeersResponse.received)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DecideExchangeResponse

// bool success = 1 [json_name = "success"];
inline void DecideExchangeResponse::clear_success() {
  success_ = false;
}
inline bool DecideExchangeResponse::_internal_success() const {
  return success_;
}
inline bool DecideExchangeResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeResponse.success)
  return _internal_success();
}
inline void DecideExchangeResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void DecideExchangeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeResponse.success)
}

// string error = 2 [json_name = "error"];
inline void DecideExchangeResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& DecideExchangeResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.DecideExchangeResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecideExchangeResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.DecideExchangeResponse.error)
}
inline std::string* DecideExchangeResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.DecideExchangeResponse.error)
  return _s;
}
inline const std::string& DecideExchangeResponse::_internal_error() const {
  return error_.Get();
}
inline void DecideExchangeResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecideExchangeResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecideExchangeResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.DecideExchangeResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecideExchangeResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.DecideExchangeResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int DecideExchangeResponse::_internal_records_size() const {
  return records_.size();
}
inline int DecideExchangeResponse::records_size() const {
  return _internal_records_size();
}
inline void DecideExchangeResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DecideExchangeResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DecideExchangeResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.DecideExchangeResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DecideExchangeResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DecideExchangeResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.DecideExchangeResponse.records)
  return _internal_mutable_records();
}

// -------------------------------------------------------------------

// SendExchangeResponse

// bool success = 1 [json_name = "success"];
inline void SendExchangeResponse::clear_success() {
  success_ = false;
}
inline bool SendExchangeResponse::_internal_success() const {
  return success_;
}
inline bool SendExchangeResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SendExchangeResponse.success)
  return _internal_success();
}
inline void SendExchangeResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void SendExchangeResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.SendExchangeResponse.success)
}

// string error = 2 [json_name = "error"];
inline void SendExchangeResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& SendExchangeResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.SendExchangeResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendExchangeResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.SendExchangeResponse.error)
}
inline std::string* SendExchangeResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.SendExchangeResponse.error)
  return _s;
}
inline const std::string& SendExchangeResponse::_internal_error() const {
  return error_.Get();
}
inline void SendExchangeResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendExchangeResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendExchangeResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.SendExchangeResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendExchangeResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.SendExchangeResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CacheRecordResponse

// bool success = 1 [json_name = "success"];
inline void CacheRecordResponse::clear_success() {
  success_ = false;
}
inline bool CacheRecordResponse::_internal_success() const {
  return success_;
}
inline bool CacheRecordResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordResponse.success)
  return _internal_success();
}
inline void CacheRecordResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void CacheRecordResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordResponse.success)
}

// string error = 2 [json_name = "error"];
inline void CacheRecordResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& CacheRecordResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.CacheRecordResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheRecordResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.CacheRecordResponse.error)
}
inline std::string* CacheRecordResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.CacheRecordResponse.error)
  return _s;
}
inline const std::string& CacheRecordResponse::_internal_error() const {
  return error_.Get();
}
inline void CacheRecordResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheRecordResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheRecordResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.CacheRecordResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CacheRecordResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.CacheRecordResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int CacheRecordResponse::_internal_records_size() const {
  return records_.size();
}
inline int CacheRecordResponse::records_size() const {
  return _internal_records_size();
}
inline void CacheRecordResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CacheRecordResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CacheRecordResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.CacheRecordResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CacheRecordResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CacheRecordResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.CacheRecordResponse.records)
  return _internal_mutable_records();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetRecordResponse

// bool success = 1 [json_name = "success"];
inline void GetRecordResponse::clear_success() {
  success_ = false;
}
inline bool GetRecordResponse::_internal_success() const {
  return success_;
}
inline bool GetRecordResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordResponse.success)
  return _internal_success();
}
inline void GetRecordResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetRecordResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordResponse.success)
}

// string error = 2 [json_name = "error"];
inline void GetRecordResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& GetRecordResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.GetRecordResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetRecordResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.GetRecordResponse.error)
}
inline std::string* GetRecordResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.GetRecordResponse.error)
  return _s;
}
inline const std::string& GetRecordResponse::_internal_error() const {
  return error_.Get();
}
inline void GetRecordResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetRecordResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetRecordResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.GetRecordResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetRecordResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.GetRecordResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int GetRecordResponse::_internal_records_size() const {
  return records_.size();
}
inline int GetRecordResponse::records_size() const {
  return _internal_records_size();
}
inline void GetRecordResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetRecordResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetRecordResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.GetRecordResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetRecordResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetRecordResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.GetRecordResponse.records)
  return _internal_mutable_records();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StoreRecordResponse

// bool success = 1 [json_name = "success"];
inline void StoreRecordResponse::clear_success() {
  success_ = false;
}
inline bool StoreRecordResponse::_internal_success() const {
  return success_;
}
inline bool StoreRecordResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordResponse.success)
  return _internal_success();
}
inline void StoreRecordResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void StoreRecordResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordResponse.success)
}

// string error = 2 [json_name = "error"];
inline void StoreRecordResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& StoreRecordResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.StoreRecordResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreRecordResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.StoreRecordResponse.error)
}
inline std::string* StoreRecordResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.StoreRecordResponse.error)
  return _s;
}
inline const std::string& StoreRecordResponse::_internal_error() const {
  return error_.Get();
}
inline void StoreRecordResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreRecordResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreRecordResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.StoreRecordResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StoreRecordResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.StoreRecordResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int StoreRecordResponse::_internal_records_size() const {
  return records_.size();
}
inline int StoreRecordResponse::records_size() const {
  return _internal_records_size();
}
inline void StoreRecordResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StoreRecordResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StoreRecordResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.StoreRecordResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StoreRecordResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StoreRecordResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.StoreRecordResponse.records)
  return _internal_mutable_records();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// RegisterNameResponse

// bool success = 1 [json_name = "success"];
inline void RegisterNameResponse::clear_success() {
  success_ = false;
}
inline bool RegisterNameResponse::_internal_success() const {
  return success_;
}
inline bool RegisterNameResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameResponse.success)
  return _internal_success();
}
inline void RegisterNameResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void RegisterNameResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameResponse.success)
}

// string error = 2 [json_name = "error"];
inline void RegisterNameResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& RegisterNameResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.RegisterNameResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterNameResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.RegisterNameResponse.error)
}
inline std::string* RegisterNameResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.RegisterNameResponse.error)
  return _s;
}
inline const std::string& RegisterNameResponse::_internal_error() const {
  return error_.Get();
}
inline void RegisterNameResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisterNameResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisterNameResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.RegisterNameResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisterNameResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.RegisterNameResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int RegisterNameResponse::_internal_records_size() const {
  return records_.size();
}
inline int RegisterNameResponse::records_size() const {
  return _internal_records_size();
}
inline void RegisterNameResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegisterNameResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
RegisterNameResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.RegisterNameResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegisterNameResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
RegisterNameResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.RegisterNameResponse.records)
  return _internal_mutable_records();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// VerifyNameResponse

// bool success = 1 [json_name = "success"];
inline void VerifyNameResponse::clear_success() {
  success_ = false;
}
inline bool VerifyNameResponse::_internal_success() const {
  return success_;
}
inline bool VerifyNameResponse::success() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameResponse.success)
  return _internal_success();
}
inline void VerifyNameResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void VerifyNameResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameResponse.success)
}

// string error = 2 [json_name = "error"];
inline void VerifyNameResponse::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& VerifyNameResponse::error() const {
  // @@protoc_insertion_point(field_get:node.highway.v1.VerifyNameResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyNameResponse::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:node.highway.v1.VerifyNameResponse.error)
}
inline std::string* VerifyNameResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:node.highway.v1.VerifyNameResponse.error)
  return _s;
}
inline const std::string& VerifyNameResponse::_internal_error() const {
  return error_.Get();
}
inline void VerifyNameResponse::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyNameResponse::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyNameResponse::release_error() {
  // @@protoc_insertion_point(field_release:node.highway.v1.VerifyNameResponse.error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyNameResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:node.highway.v1.VerifyNameResponse.error)
}

// map<string, string> records = 3 [json_name = "records"];
inline int VerifyNameResponse::_internal_records_size() const {
  return records_.size();
}
inline int VerifyNameResponse::records_size() const {
  return _internal_records_size();
}
inline void VerifyNameResponse::clear_records() {
  records_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VerifyNameResponse::_internal_records() const {
  return records_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
VerifyNameResponse::records() const {
  // @@protoc_insertion_point(field_map:node.highway.v1.VerifyNameResponse.records)
  return _internal_records();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VerifyNameResponse::_internal_mutable_records() {
  return records_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
VerifyNameResponse::mutable_records() {
  // @@protoc_insertion_point(field_mutable_map:node.highway.v1.VerifyNameResponse.records)
  return _internal_mutable_records();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace highway
}  // namespace node

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_node_2fhighway_2fv1_2fresponse_2eproto
